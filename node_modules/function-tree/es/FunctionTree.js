var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import EventEmitter from 'eventemitter3';
import executeTree from './executeTree';
import createStaticTree from './staticTree';
import resolveProvider from './providers/Resolve';
import Path from './Path';
import Provider from './Provider';
import { Primitive } from './primitives';
import { FunctionTreeExecutionError } from './errors';
import { isPromise } from './utils';

/*
  Need to create a unique ID for each execution to identify it
  in debugger
*/
function createUniqueId() {
  return Date.now() + '_' + Math.floor(Math.random() * 10000);
}

/*
  Validate any returned value from a function. Has
  to be nothing or an object
*/
function isValidResult(result) {
  return !result || (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && !Array.isArray(result);
}

/*
  Create an error with execution details
*/
function createErrorObject(error, execution, functionDetails, payload) {
  var errorToReturn = error;

  errorToReturn.execution = execution;
  errorToReturn.functionDetails = functionDetails;
  errorToReturn.payload = Object.assign({}, payload, {
    _execution: {
      id: execution.id,
      functionIndex: functionDetails.functionIndex
    },
    error: error.toJSON ? error.toJSON() : {
      name: error.name,
      message: error.message,
      stack: error.stack
    }
  });

  return errorToReturn;
}

var FunctionTreeExecution = function () {
  function FunctionTreeExecution(name, staticTree, functionTree, errorCallback) {
    _classCallCheck(this, FunctionTreeExecution);

    this.id = createUniqueId();
    this.name = name || staticTree.name || this.id;
    this.staticTree = staticTree;
    this.functionTree = functionTree;
    this.datetime = Date.now();
    this.errorCallback = errorCallback;
    this.hasThrown = false;
    this.isAsync = false;

    this.runFunction = this.runFunction.bind(this);
  }

  /*
    Creates the context for the current function to be run,
    emits events and handles its returned value. Also handles
    the returned value being a promise
  */


  _createClass(FunctionTreeExecution, [{
    key: 'runFunction',
    value: function runFunction(funcDetails, payload, prevPayload, next) {
      if (this.hasThrown) {
        return;
      }

      var context = this.createContext(funcDetails, payload, prevPayload);
      var functionTree = this.functionTree;
      var errorCallback = this.errorCallback;
      var execution = this;
      var result = void 0;

      functionTree.emit('functionStart', execution, funcDetails, payload);
      try {
        result = funcDetails.function(context);
      } catch (error) {
        this.hasThrown = true;

        return errorCallback(createErrorObject(error, execution, funcDetails, payload), execution, funcDetails, payload);
      }

      /*
        If result is a promise we want to emit an event and wait for it to resolve to
        move on
      */
      if (isPromise(result)) {
        functionTree.emit('asyncFunction', execution, funcDetails, payload, result);
        this.isAsync = true;
        result.then(function (result) {
          if (result instanceof Path) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next(result.toJSON());
          } else if (funcDetails.outputs) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            throw new FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' needs to be a path of either ' + Object.keys(funcDetails.outputs)));
          } else if (isValidResult(result)) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next({
              payload: result
            });
          } else {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            throw new FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' is not a valid result'));
          }
        }).catch(function (result) {
          if (execution.hasThrown) {
            return;
          }

          if (result instanceof Error) {
            execution.hasThrown = true;
            errorCallback(createErrorObject(result, execution, funcDetails, payload), execution, funcDetails, payload);
          } else if (result instanceof Path) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next(result.toJSON());
          } else if (funcDetails.outputs) {
            var error = new FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' needs to be a path of either ' + Object.keys(funcDetails.outputs)));

            execution.hasThrown = true;
            errorCallback(createErrorObject(error, execution, funcDetails, payload), execution, funcDetails, payload);
          } else if (isValidResult(result)) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next({
              payload: result
            });
          } else {
            var _error = new FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' is not a valid result'));
            execution.hasThrown = true;

            errorCallback(createErrorObject(_error, execution, funcDetails, payload), execution, funcDetails, payload);
          }
        });
      } else if (result instanceof Path) {
        functionTree.emit('functionEnd', execution, funcDetails, payload, result);
        next(result.toJSON());
      } else if (funcDetails.outputs) {
        var error = new FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' needs to be a path of either ' + Object.keys(funcDetails.outputs)));

        this.hasThrown = true;
        errorCallback(createErrorObject(error, execution, funcDetails, payload), execution, funcDetails, payload);
      } else if (isValidResult(result)) {
        functionTree.emit('functionEnd', execution, funcDetails, payload, result);
        next({
          payload: result
        });
      } else {
        var _error2 = new FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' is not a valid result'));
        this.hasThrown = true;

        errorCallback(createErrorObject(_error2, execution, funcDetails, payload), execution, funcDetails, payload);
      }
    }

    /*
      Creates the context for the next running function
    */

  }, {
    key: 'createContext',
    value: function createContext(functionDetails, payload, prevPayload) {
      var contextProviders = this.functionTree.contextProviders;
      var newContext = {
        execution: this,
        props: payload || {},
        functionDetails: functionDetails,
        path: functionDetails.outputs ? Object.keys(functionDetails.outputs).reduce(function (output, outputPath) {
          output[outputPath] = function (payload) {
            return new Path(outputPath, payload);
          };

          return output;
        }, {}) : null
      };

      var debuggerProvider = contextProviders.debugger && contextProviders.debugger.get(newContext, functionDetails, payload, prevPayload);

      var context = Object.keys(contextProviders).reduce(function (currentContext, name) {
        var provider = contextProviders[name];

        if (provider instanceof Provider) {
          currentContext[name] = provider.get(currentContext, functionDetails, payload, prevPayload);
        } else {
          currentContext[name] = provider;
        }

        return currentContext;
      }, newContext);

      if (debuggerProvider) {
        return Object.keys(context).reduce(function (currentContext, name) {
          var provider = contextProviders[name];

          if (provider && provider instanceof Provider && provider.wrap) {
            currentContext[name] = typeof provider.wrap === 'function' ? provider.wrap(context, functionDetails) : provider.getWrapped(name, context);
          } else {
            currentContext[name] = context[name];
          }

          return currentContext;
        }, {});
      }

      return context;
    }
  }]);

  return FunctionTreeExecution;
}();

export var FunctionTree = function (_EventEmitter) {
  _inherits(FunctionTree, _EventEmitter);

  function FunctionTree() {
    var contextProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, FunctionTree);

    var _this = _possibleConstructorReturn(this, (FunctionTree.__proto__ || Object.getPrototypeOf(FunctionTree)).call(this));

    _this.cachedTrees = [];
    _this.cachedStaticTrees = [];
    _this.executeBranchWrapper = options.executeBranchWrapper || function (cb) {
      cb();
    };

    if ((typeof contextProviders === 'undefined' ? 'undefined' : _typeof(contextProviders)) !== 'object' || contextProviders === null || Array.isArray(contextProviders)) {
      throw new Error('You have to pass an object of context providers to FunctionTree');
    }

    var providerKeys = Object.keys(contextProviders);

    if (providerKeys.indexOf('props') >= 0 || providerKeys.indexOf('path') >= 0 || providerKeys.indexOf('resolve') >= 0 || providerKeys.indexOf('execution') >= 0 || providerKeys.indexOf('debugger') >= 0) {
      throw new Error('You are trying to add a provider with protected key. "props", "path", "resolve", "execution" and "debugger" are protected');
    }

    _this.contextProviders = Object.assign({}, contextProviders, {
      resolve: resolveProvider
    });

    _this.run = _this.run.bind(_this);
    return _this;
  }

  /*
    Analyses the tree to identify paths and its validity. This analysis
    is cached. Then the method creates an execution for the tree to run.
  */


  _createClass(FunctionTree, [{
    key: 'run',
    value: function run() {
      var _this2 = this;

      var name = void 0;
      var tree = void 0;
      var payload = void 0;
      var cb = void 0;
      var staticTree = void 0;
      var args = [].slice.call(arguments);
      args.forEach(function (arg) {
        if (typeof arg === 'string') {
          name = arg;
        } else if (Array.isArray(arg) || arg instanceof Primitive) {
          tree = arg;
        } else if (!tree && typeof arg === 'function') {
          tree = arg;
        } else if (typeof arg === 'function') {
          cb = arg;
        } else {
          payload = arg;
        }
      });

      if (!tree) {
        throw new Error('function-tree - You did not pass in a function tree');
      }

      var withResolveAndReject = function withResolveAndReject(resolve, reject) {
        var treeIdx = _this2.cachedTrees.indexOf(tree);
        if (treeIdx === -1) {
          staticTree = createStaticTree(name, tree);
          _this2.cachedTrees.push(tree);
          _this2.cachedStaticTrees.push(staticTree);
        } else {
          staticTree = _this2.cachedStaticTrees[treeIdx];
        }
        var execution = new FunctionTreeExecution(name, staticTree, _this2, function (error, execution, funcDetails, finalPayload) {
          _this2.emit('error', error, execution, funcDetails, finalPayload);
          reject(error);
        });

        _this2.emit('start', execution, payload);
        executeTree(execution, payload, _this2.executeBranchWrapper, function (funcDetails, path, currentPayload) {
          _this2.emit('pathStart', path, execution, funcDetails, currentPayload);
        }, function (currentPayload) {
          _this2.emit('pathEnd', execution, currentPayload);
        }, function (currentPayload, functionsToResolve) {
          _this2.emit('parallelStart', execution, currentPayload, functionsToResolve);
        }, function (currentPayload, functionsResolved) {
          _this2.emit('parallelProgress', execution, currentPayload, functionsResolved);
        }, function (currentPayload, functionsResolved) {
          _this2.emit('parallelEnd', execution, currentPayload, functionsResolved);
        }, function (finalPayload) {
          _this2.emit('end', execution, finalPayload);
          resolve === reject ? resolve(null, finalPayload) : resolve(finalPayload);
        });
      };

      if (cb) {
        withResolveAndReject(cb, cb);
      } else {
        return new Promise(withResolveAndReject);
      }
    }
  }]);

  return FunctionTree;
}(EventEmitter);
//# sourceMappingURL=FunctionTree.js.map