import * as assert from 'assert';
import { SequenceFactory, SequenceWithPropsFactory, } from './';
var Sequence = SequenceFactory();
var SequenceWithProps = SequenceWithPropsFactory();
describe('Fluent', function () {
    it('should return array', function () {
        function action1(context) { }
        var seq = Sequence(function (x) { return x.action(action1); });
        assert.deepEqual(seq, [action1]);
    });
    it('should return paths correctly', function () {
        function action1(context) { }
        function action2(context) { }
        function action3(context) {
            context.state.stateData = 'Something';
            return context.path.success({ newName: 'John' });
        }
        var seq = SequenceWithProps(function (x) {
            return x
                .action(action1)
                .branch(action3)
                .paths({
                success: function (z) { return z.action(action1, action2); },
                error: function (z) { return z.action(action2); },
            });
        });
        assert.deepEqual(seq, [
            action1,
            action3,
            {
                success: [action1, action2],
                error: [action2],
            },
        ]);
    });
    describe('inference', function () {
        it('should infer props on next inline action', function () {
            function action1(context) {
                return {
                    foo: 'bar',
                };
            }
            Sequence(function (s) {
                return s.action(action1).action(function action2(_a) {
                    var props = _a.props;
                    props.foo = 'bar2';
                });
            });
        });
        it('should infer props on next action with required props', function () {
            function action1(context) {
                return {
                    foo: 'bar',
                };
            }
            function action2(context) {
                context.props.foo = 'bar2';
            }
            Sequence(function (s) { return s.action(action1).action(action2); });
        });
        it('should infer promise props on actions', function () {
            function action1(context) {
                return Promise.resolve({
                    foo: 'bar',
                });
            }
            function action2(context) {
                context.props.foo = 'bar2';
            }
            Sequence(function (s) { return s.action(action1).action(action2); });
        });
        it('should infer props on paths', function () {
            function action1(context) {
                if (Math.random()) {
                    return context.path.pathA({ foo: 'bar' });
                }
                return context.path.pathB({ bar: 123 });
            }
            Sequence(function (s) {
                return s.branch(action1).paths({
                    pathA: function (s) {
                        return s.action(function action2(_a) {
                            var props = _a.props;
                            props.foo = 'bar';
                        });
                    },
                    pathB: function (s) {
                        return s.action(function action3(_a) {
                            var props = _a.props;
                            props.bar.toFixed();
                        });
                    },
                });
            });
        });
        it('should infer promise props on paths', function () {
            function action1(context) {
                return Promise.resolve()
                    .then(function () {
                    return context.path.pathA({ foo: 'bar' });
                })
                    .catch(function () {
                    return context.path.pathB({ bar: 123 });
                });
            }
            Sequence(function (s) {
                return s.branch(action1).paths({
                    pathA: function (s) {
                        return s.action(function action2(_a) {
                            var props = _a.props;
                            props.foo = 'bar';
                        });
                    },
                    pathB: function (s) {
                        return s.action(function action3(_a) {
                            var props = _a.props;
                            props.bar.toFixed();
                        });
                    },
                });
            });
        });
        it('should infer sequence composition', function () {
            var seqA = SequenceWithProps(function (s) {
                return s.action(function action1(_a) {
                    var props = _a.props;
                    props.foo = 'bar2';
                    return {
                        bar: 123,
                    };
                });
            });
            Sequence(function (s) {
                return s
                    .action(function action2() {
                    return {
                        foo: 'bar',
                    };
                })
                    .sequence(seqA)
                    .action(function action3(_a) {
                    var props = _a.props;
                    props.bar.toFixed();
                });
            });
        });
    });
});
//# sourceMappingURL=index.spec.js.map