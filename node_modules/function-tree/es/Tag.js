var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import { ResolveValue } from './ResolveValue';

/*
  Creates tag for targetting things with a path in Cerebral
*/
export var Tag = function (_ResolveValue) {
  _inherits(Tag, _ResolveValue);

  function Tag(type, getter, strings, values) {
    _classCallCheck(this, Tag);

    var _this = _possibleConstructorReturn(this, (Tag.__proto__ || Object.getPrototypeOf(Tag)).call(this));

    _this.type = type;
    _this.getter = getter;
    _this.strings = strings;
    _this.values = values;
    return _this;
  }
  /*
    Returns all tags, also nested to identify nested state dependencies
    in components
  */


  _createClass(Tag, [{
    key: 'getTags',
    value: function getTags() {
      return [this].concat(this.getNestedTags());
    }
    /*
      Gets the path of the tag, where nested tags are evaluated
    */

  }, {
    key: 'getPath',
    value: function getPath(context) {
      var _this2 = this;

      return this.strings.reduce(function (currentPath, string, idx) {
        var valueTemplate = _this2.values[idx];

        if (valueTemplate instanceof ResolveValue) {
          return currentPath + string + valueTemplate.getValue(context);
        }

        return currentPath + string + (valueTemplate !== undefined ? valueTemplate : '');
      }, '');
    }
  }, {
    key: 'getValue',
    value: function getValue(context) {
      return this.getter(this.getPath(context), context);
    }
    /*
      Grab nested tags from the tags current path
    */

  }, {
    key: 'getNestedTags',
    value: function getNestedTags() {
      var _this3 = this;

      return this.strings.reduce(function (currentPaths, string, idx) {
        var valueTemplate = _this3.values[idx];

        if (valueTemplate instanceof Tag) {
          return currentPaths.concat(valueTemplate);
        }

        return currentPaths;
      }, []);
    }
    /*
      Produces a string representation of the tag
    */

  }, {
    key: 'toString',
    value: function toString() {
      return this.type + '`' + this.pathToString() + '`';
    }
    /*
      Produces a string representation of the path
    */

  }, {
    key: 'pathToString',
    value: function pathToString() {
      var _this4 = this;

      return this.strings.reduce(function (currentPath, string, idx) {
        var valueTemplate = _this4.values[idx];

        if (valueTemplate instanceof Tag) {
          return currentPath + string + '${' + valueTemplate.toString() + '}';
        }

        return currentPath + string + (valueTemplate !== undefined ? valueTemplate : '');
      }, '');
    }
  }]);

  return Tag;
}(ResolveValue);

export function createTemplateTag(tag, getValue) {
  return function (strings) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    if (values.some(function (value) {
      return value === undefined;
    })) {
      throw new Error('One of the values passed inside the tag interpolated to undefined. Please check.');
    }
    return new Tag(tag, getValue, strings, values);
  };
}
//# sourceMappingURL=Tag.js.map