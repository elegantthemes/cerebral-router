{"version":3,"sources":["../src/staticTree.js"],"names":["Sequence","Parallel","Primitive","FunctionTreeError","getFunctionName","fn","displayName","name","ret","toString","startNameMatch","indexOf","substr","length","isPaths","item","Array","isArray","stringifyInvalidTreeItem","items","invalidItem","map","type","toUpperCase","join","analyze","functions","isParallel","instance","toJSON","Object","assign","reduce","allItems","subItem","index","concat","funcDetails","functionIndex","push","function","nextItem","outputs","keys","forEach","key","tree"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,QAAnB,EAA6BC,SAA7B,QAA8C,cAA9C;AACA,SAASC,iBAAT,QAAkC,UAAlC;;AAEA,SAASC,eAAT,CAAyBC,EAAzB,EAA6B;AAC3B,MAAIA,GAAGC,WAAP,EAAoB,OAAOD,GAAGC,WAAV;AACpB,MAAID,GAAGE,IAAP,EAAa,OAAOF,GAAGE,IAAV;;AAEb,MAAIC,MAAMH,GAAGI,QAAH,EAAV;;AAEA,MAAIC,uBAAJ;AACA,MAAIF,IAAIG,OAAJ,CAAY,gBAAZ,MAAkC,CAAtC,EAAyCD,iBAAiB,iBAAjB,CAAzC,KACK,IAAIF,IAAIG,OAAJ,CAAY,UAAZ,MAA4B,CAAhC,EAAmCD,iBAAiB,WAAjB;;AAExCF,QAAMA,IAAII,MAAJ,CAAWF,iBAAiBA,eAAeG,MAAhC,GAAyC,CAApD,CAAN;AACAL,QAAMA,IAAII,MAAJ,CAAW,CAAX,EAAcJ,IAAIG,OAAJ,CAAY,GAAZ,CAAd,CAAN;;AAEA,SAAOH,GAAP;AACD;;AAED,SAASM,OAAT,CAAiBC,IAAjB,EAAuB;AACrB,SACEA,QACA,CAACC,MAAMC,OAAN,CAAcF,IAAd,CADD,IAEA,QAAOA,IAAP,yCAAOA,IAAP,OAAgB,QAFhB,IAGA,EAAEA,gBAAgBb,SAAlB,CAJF;AAMD;;AAED,SAASgB,wBAAT,CAAkCC,KAAlC,EAAyCC,WAAzC,EAAsD;AACpD,mBAEAD,MACGE,GADH,CACO,UAACN,IAAD,EAAU;AACb,QAAIA,SAASK,WAAb,EAA0B;AACxB,4BAAmBA,WAAnB,yCAAmBA,WAAnB;AACD;AACD,QAAI,OAAOL,IAAP,KAAgB,UAApB,EAAgC;AAC9B,oBAAYX,gBAAgBW,IAAhB,CAAZ;AACD;AACD,QAAIA,gBAAgBb,SAApB,EAA+B;AAC7B,sBAAca,KAAKO,IAAL,CAAUC,WAAV,EAAd;AACD;AACD,QAAIP,MAAMC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;AACvB;AACD;;AAED;AACD,GAhBH,EAiBGS,IAjBH,CAiBQ,IAjBR,CAFA;AAsBD;;AAED,SAASC,OAAT,CAAiBlB,IAAjB,EAAuBmB,SAAvB,EAAkCX,IAAlC,EAAwCY,UAAxC,EAAoD;AAClD,MAAIZ,gBAAgBb,SAApB,EAA+B;AAC7B,QAAM0B,WAAWb,KAAKc,MAAL,EAAjB;;AAEA,WAAOC,OAAOC,MAAP,CAAcH,QAAd,EAAwB;AAC7BT,aAAOM,QAAQlB,IAAR,EAAcmB,SAAd,EAAyBE,SAAST,KAAlC,EAAyCJ,gBAAgBd,QAAzD,EACJkB;AAF0B,KAAxB,CAAP;AAID,GAPD,MAOO,IAAIH,MAAMC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;AAC9B,WAAO,IAAIf,QAAJ,CACLe,KAAKiB,MAAL,CAAY,UAACC,QAAD,EAAWC,OAAX,EAAoBC,KAApB,EAA8B;AACxC,UAAID,mBAAmBhC,SAAvB,EAAkC;AAChC,YAAM0B,YAAWM,QAAQL,MAAR,EAAjB;;AAEA,eAAOI,SAASG,MAAT,CACLN,OAAOC,MAAP,CAAcH,SAAd,EAAwB;AACtBT,iBAAOM,QACLlB,IADK,EAELmB,SAFK,EAGLE,UAAST,KAHJ,EAILe,mBAAmBjC,QAJd,EAKLkB;AANoB,SAAxB,CADK,CAAP;AAUD,OAbD,MAaO,IAAI,OAAOe,OAAP,KAAmB,UAAvB,EAAmC;AACxC,YAAMG,cAAc;AAClB9B,gBAAM2B,QAAQ5B,WAAR,IAAuBF,gBAAgB8B,OAAhB,CADX;AAElBI,yBAAeZ,UAAUa,IAAV,CAAeL,OAAf,IAA0B,CAFvB;AAGlBM,oBAAUN;AAHQ,SAApB;AAKA,YAAMO,WAAW1B,KAAKoB,QAAQ,CAAb,CAAjB;;AAEA,YAAIrB,QAAQ2B,QAAR,CAAJ,EAAuB;AACrBJ,sBAAYK,OAAZ,GAAsB,EAAtB;AACAZ,iBAAOa,IAAP,CAAYF,QAAZ,EAAsBG,OAAtB,CAA8B,UAACC,GAAD,EAAS;AACrC,gBAAIX,QAAQQ,OAAR,IAAmB,CAAC,CAACR,QAAQQ,OAAR,CAAgB/B,OAAhB,CAAwBkC,GAAxB,CAAzB,EAAuD;AACrD,oBAAM,IAAI1C,iBAAJ,gFAAN;AAGD;AACDkC,wBAAYK,OAAZ,CAAoBG,GAApB,IAA2BpB,QACzBlB,IADyB,EAEzBmB,SAFyB,EAGzB,OAAOe,SAASI,GAAT,CAAP,KAAyB,UAAzB,GACI,CAACJ,SAASI,GAAT,CAAD,CADJ,GAEIJ,SAASI,GAAT,CALqB,CAA3B;AAOD,WAbD;AAcD;;AAED,eAAOZ,SAASG,MAAT,CAAgBC,WAAhB,CAAP;AACD,OA3BM,MA2BA,IAAIvB,QAAQoB,OAAR,CAAJ,EAAsB;AAC3B,eAAOD,QAAP;AACD,OAFM,MAEA,IAAIjB,MAAMC,OAAN,CAAciB,OAAd,CAAJ,EAA4B;AACjC,YAAMf,QAAQM,QAAQlB,IAAR,EAAcmB,SAAd,EAAyBQ,OAAzB,CAAd;;AAEA,eAAOD,SAASG,MAAT,CAAgBjB,KAAhB,CAAP;AACD,OAJM,MAIA;AACL,cAAM,IAAIhB,iBAAJ,2BACoBI,IADpB,WAC8BW,yBAChCH,IADgC,EAEhCmB,OAFgC,CAD9B,CAAN;AAMD;AACF,KAvDD,EAuDG,EAvDH,CADK,EAyDLL,MAzDK,EAAP;AA0DD,GA3DM,MA2DA;AACL,UAAM,IAAI1B,iBAAJ,CAAsB,0BAAtB,CAAN;AACD;AACF;;AAED,gBAAe,UAACI,IAAD,EAAOuC,IAAP,EAAgB;AAC7B,MAAMpB,YAAY,EAAlB;;AAEA,SAAOD,QAAQlB,IAAR,EAAcmB,SAAd,EAAyB,OAAOoB,IAAP,KAAgB,UAAhB,GAA6B,CAACA,IAAD,CAA7B,GAAsCA,IAA/D,CAAP;AACD,CAJD","file":"staticTree.js","sourcesContent":["import { Sequence, Parallel, Primitive } from './primitives'\nimport { FunctionTreeError } from './errors'\n\nfunction getFunctionName(fn) {\n  if (fn.displayName) return fn.displayName\n  if (fn.name) return fn.name\n\n  let ret = fn.toString()\n\n  let startNameMatch\n  if (ret.indexOf('async function') === 0) startNameMatch = 'async function '\n  else if (ret.indexOf('function') === 0) startNameMatch = 'function '\n\n  ret = ret.substr(startNameMatch ? startNameMatch.length : 0)\n  ret = ret.substr(0, ret.indexOf('('))\n\n  return ret\n}\n\nfunction isPaths(item) {\n  return (\n    item &&\n    !Array.isArray(item) &&\n    typeof item === 'object' &&\n    !(item instanceof Primitive)\n  )\n}\n\nfunction stringifyInvalidTreeItem(items, invalidItem) {\n  return `\n[\n${items\n    .map((item) => {\n      if (item === invalidItem) {\n        return `  ${typeof invalidItem}, <-- PROBLEM`\n      }\n      if (typeof item === 'function') {\n        return `  ${getFunctionName(item)},`\n      }\n      if (item instanceof Primitive) {\n        return `  [ ${item.type.toUpperCase()} ],`\n      }\n      if (Array.isArray(item)) {\n        return `  [ SEQUENCE ],`\n      }\n\n      return `  { PATHS },`\n    })\n    .join('\\n')}\n]\n  `\n}\n\nfunction analyze(name, functions, item, isParallel) {\n  if (item instanceof Primitive) {\n    const instance = item.toJSON()\n\n    return Object.assign(instance, {\n      items: analyze(name, functions, instance.items, item instanceof Parallel)\n        .items,\n    })\n  } else if (Array.isArray(item)) {\n    return new Sequence(\n      item.reduce((allItems, subItem, index) => {\n        if (subItem instanceof Primitive) {\n          const instance = subItem.toJSON()\n\n          return allItems.concat(\n            Object.assign(instance, {\n              items: analyze(\n                name,\n                functions,\n                instance.items,\n                subItem instanceof Parallel\n              ).items,\n            })\n          )\n        } else if (typeof subItem === 'function') {\n          const funcDetails = {\n            name: subItem.displayName || getFunctionName(subItem),\n            functionIndex: functions.push(subItem) - 1,\n            function: subItem,\n          }\n          const nextItem = item[index + 1]\n\n          if (isPaths(nextItem)) {\n            funcDetails.outputs = {}\n            Object.keys(nextItem).forEach((key) => {\n              if (subItem.outputs && !~subItem.outputs.indexOf(key)) {\n                throw new FunctionTreeError(\n                  `Outputs object doesn't match list of possible outputs defined for function.`\n                )\n              }\n              funcDetails.outputs[key] = analyze(\n                name,\n                functions,\n                typeof nextItem[key] === 'function'\n                  ? [nextItem[key]]\n                  : nextItem[key]\n              )\n            })\n          }\n\n          return allItems.concat(funcDetails)\n        } else if (isPaths(subItem)) {\n          return allItems\n        } else if (Array.isArray(subItem)) {\n          const items = analyze(name, functions, subItem)\n\n          return allItems.concat(items)\n        } else {\n          throw new FunctionTreeError(\n            `Unexpected entry in \"${name}\". ${stringifyInvalidTreeItem(\n              item,\n              subItem\n            )}`\n          )\n        }\n      }, [])\n    ).toJSON()\n  } else {\n    throw new FunctionTreeError('Unexpected entry in tree')\n  }\n}\n\nexport default (name, tree) => {\n  const functions = []\n\n  return analyze(name, functions, typeof tree === 'function' ? [tree] : tree)\n}\n"]}