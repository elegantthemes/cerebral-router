{"version":3,"sources":["../src/executeTree.js"],"names":["FunctionTreeExecutionError","isPrimitive","primitive","type","_functionTreePrimitive","executeTree","execution","initialPayload","executeBranchWrapper","branchStart","branchEnd","parallelStart","parallelProgress","parallelEnd","end","runBranch","branch","index","payload","prevPayload","nextBranch","runNextItem","result","processFunctionOutput","funcDetails","outputResult","newPayload","Object","assign","outputs","keys","indexOf","path","items","name","join","currentItem","staticTree","itemLength","length","payloads","forEach","func","function","runFunction","push","apply","concat"],"mappings":"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","file":"executeTree.js","sourcesContent":["import { FunctionTreeExecutionError } from './errors'\n\nfunction isPrimitive(primitive, type) {\n  return primitive._functionTreePrimitive && primitive.type === type\n}\n\n/*\n  Runs through the tree providing a \"next\" callback to process next step\n  of execution\n*/\nexport default function executeTree(\n  execution,\n  initialPayload,\n  executeBranchWrapper,\n  branchStart,\n  branchEnd,\n  parallelStart,\n  parallelProgress,\n  parallelEnd,\n  end\n) {\n  function runBranch(branch, index, payload, prevPayload, nextBranch) {\n    executeBranchWrapper(() => {\n      function runNextItem(result) {\n        runBranch(branch, index + 1, result, payload, nextBranch)\n      }\n\n      function processFunctionOutput(funcDetails, outputResult) {\n        return function(result) {\n          const newPayload = Object.assign(\n            {},\n            payload,\n            result ? result.payload : {}\n          )\n\n          if (result && funcDetails.outputs) {\n            const outputs = Object.keys(funcDetails.outputs)\n\n            if (~outputs.indexOf(result.path)) {\n              branchStart(funcDetails, result.path, newPayload)\n              runBranch(\n                funcDetails.outputs[result.path].items,\n                0,\n                newPayload,\n                payload,\n                outputResult\n              )\n            } else {\n              throw new FunctionTreeExecutionError(\n                execution,\n                funcDetails,\n                payload,\n                `function ${\n                  funcDetails.name\n                } must use one of its possible outputs: ${outputs.join(', ')}.`\n              )\n            }\n          } else {\n            outputResult(newPayload)\n          }\n        }\n      }\n\n      const currentItem = branch[index]\n\n      if (!currentItem) {\n        if (branch !== execution.staticTree) {\n          branchEnd(payload)\n        }\n        nextBranch(payload)\n      } else if (isPrimitive(currentItem, 'sequence')) {\n        runBranch(currentItem.items, 0, payload, prevPayload, runNextItem)\n      } else if (isPrimitive(currentItem, 'parallel')) {\n        const itemLength = currentItem.items.length\n        const payloads = []\n\n        parallelStart(payload, itemLength)\n        currentItem.items.forEach((func, index) => {\n          if (func.function) {\n            execution.runFunction(\n              func,\n              payload,\n              prevPayload,\n              processFunctionOutput(func, (payload) => {\n                payloads.push(payload)\n                if (payloads.length === itemLength) {\n                  parallelEnd(payload, itemLength)\n                  runNextItem(\n                    Object.assign.apply(Object, [{}].concat(payloads))\n                  )\n                } else {\n                  parallelProgress(payload, itemLength - payloads.length)\n                }\n              })\n            )\n          } else {\n            runBranch(func.items, 0, payload, prevPayload, function(payload) {\n              payloads.push(payload)\n              if (payloads.length === itemLength) {\n                parallelEnd(payload, itemLength)\n                runNextItem(Object.assign.apply(Object, [{}].concat(payloads)))\n              } else {\n                parallelProgress(payload, itemLength - payloads.length)\n              }\n            })\n          }\n\n          return payloads\n        })\n      } else {\n        execution.runFunction(\n          currentItem,\n          payload,\n          prevPayload,\n          processFunctionOutput(currentItem, runNextItem)\n        )\n      }\n    })\n  }\n\n  runBranch([execution.staticTree], 0, initialPayload, null, end)\n}\n"]}