var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

import { Sequence, Parallel, Primitive } from './primitives';
import { FunctionTreeError } from './errors';

function getFunctionName(fn) {
  if (fn.displayName) return fn.displayName;
  if (fn.name) return fn.name;

  var ret = fn.toString();

  var startNameMatch = void 0;
  if (ret.indexOf('async function') === 0) startNameMatch = 'async function ';else if (ret.indexOf('function') === 0) startNameMatch = 'function ';

  ret = ret.substr(startNameMatch ? startNameMatch.length : 0);
  ret = ret.substr(0, ret.indexOf('('));

  return ret;
}

function isPaths(item) {
  return item && !Array.isArray(item) && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !(item instanceof Primitive);
}

function stringifyInvalidTreeItem(items, invalidItem) {
  return '\n[\n' + items.map(function (item) {
    if (item === invalidItem) {
      return '  ' + (typeof invalidItem === 'undefined' ? 'undefined' : _typeof(invalidItem)) + ', <-- PROBLEM';
    }
    if (typeof item === 'function') {
      return '  ' + getFunctionName(item) + ',';
    }
    if (item instanceof Primitive) {
      return '  [ ' + item.type.toUpperCase() + ' ],';
    }
    if (Array.isArray(item)) {
      return '  [ SEQUENCE ],';
    }

    return '  { PATHS },';
  }).join('\n') + '\n]\n  ';
}

function analyze(name, functions, item, isParallel) {
  if (item instanceof Primitive) {
    var instance = item.toJSON();

    return Object.assign(instance, {
      items: analyze(name, functions, instance.items, item instanceof Parallel).items
    });
  } else if (Array.isArray(item)) {
    return new Sequence(item.reduce(function (allItems, subItem, index) {
      if (subItem instanceof Primitive) {
        var _instance = subItem.toJSON();

        return allItems.concat(Object.assign(_instance, {
          items: analyze(name, functions, _instance.items, subItem instanceof Parallel).items
        }));
      } else if (typeof subItem === 'function') {
        var funcDetails = {
          name: subItem.displayName || getFunctionName(subItem),
          functionIndex: functions.push(subItem) - 1,
          function: subItem
        };
        var nextItem = item[index + 1];

        if (isPaths(nextItem)) {
          funcDetails.outputs = {};
          Object.keys(nextItem).forEach(function (key) {
            if (subItem.outputs && !~subItem.outputs.indexOf(key)) {
              throw new FunctionTreeError('Outputs object doesn\'t match list of possible outputs defined for function.');
            }
            funcDetails.outputs[key] = analyze(name, functions, typeof nextItem[key] === 'function' ? [nextItem[key]] : nextItem[key]);
          });
        }

        return allItems.concat(funcDetails);
      } else if (isPaths(subItem)) {
        return allItems;
      } else if (Array.isArray(subItem)) {
        var items = analyze(name, functions, subItem);

        return allItems.concat(items);
      } else {
        throw new FunctionTreeError('Unexpected entry in "' + name + '". ' + stringifyInvalidTreeItem(item, subItem));
      }
    }, [])).toJSON();
  } else {
    throw new FunctionTreeError('Unexpected entry in tree');
  }
}

export default (function (name, tree) {
  var functions = [];

  return analyze(name, functions, typeof tree === 'function' ? [tree] : tree);
});
//# sourceMappingURL=staticTree.js.map