var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* global VERSION */
import _Provider from '../Provider';
import DevtoolsBase from './base';
import WebSocket from 'universal-websocket-client';

// Used by cerebral/devtools
export { default as DevtoolsBase } from './base';

export var Devtools = function (_DevtoolsBase) {
  _inherits(Devtools, _DevtoolsBase);

  function Devtools(options) {
    _classCallCheck(this, Devtools);

    var _this = _possibleConstructorReturn(this, (Devtools.__proto__ || Object.getPrototypeOf(Devtools)).call(this, options));

    _this.trees = [];
    _this.latestExecutionId = null;
    _this.version = "3.3.1";
    _this.init();
    return _this;
  }

  _createClass(Devtools, [{
    key: 'createSocket',
    value: function createSocket() {
      this.ws = new WebSocket((this.https ? 'wss' : 'ws') + '://' + this.host);
    }
  }, {
    key: 'onMessage',
    value: function onMessage(event) {
      var message = JSON.parse(event.data);
      switch (message.type) {
        case 'pong':
          this.sendInitial();
          break;
        case 'ping':
          this.sendInitial();
          break;
      }
    }
  }, {
    key: 'add',
    value: function add(tree) {
      this.trees.push(tree);
      tree.contextProviders.debugger = this.Provider();
      this.watchExecution(tree, 'ft');
    }
  }, {
    key: 'remove',
    value: function remove(tree) {
      this.trees.splice(this.trees.indexOf(tree), 1);
      delete tree.contextProviders.debugger;

      tree.removeAllListeners('start');
      tree.removeAllListeners('end');
      tree.removeAllListeners('pathStart');
      tree.removeAllListeners('functionStart');
      tree.removeAllListeners('functionEnd');
      tree.removeAllListeners('error');
    }
  }, {
    key: 'removeAll',
    value: function removeAll() {
      var _this2 = this;

      var trees = this.trees.reduce(function (newTrees, tree) {
        newTrees.push(tree);
        return newTrees;
      }, []);
      trees.forEach(function (tree) {
        _this2.remove(tree);
      });
    }
  }, {
    key: 'sendInitial',
    value: function sendInitial() {
      var message = JSON.stringify({
        type: 'init',
        source: 'ft',
        version: this.version
      });

      this.sendMessage(message);
      if (this.backlog.length) {
        this.sendBulkMessage(this.backlog, 'ft');
        this.backlog = [];
      }
      this.isConnected = true;
    }
    /*
      Create the stringified message for the debugger. As we need to
      store mutations with the default true "storeMutations" option used
      by time travel and jumping between Cerebral apps, we are careful
      not doing unnecessary stringifying.
    */

  }, {
    key: 'createExecutionMessage',
    value: function createExecutionMessage(debuggingData, execution, functionDetails, payload) {
      var type = 'execution';
      var data = {
        execution: {
          executionId: execution.id,
          functionIndex: functionDetails.functionIndex,
          payload: payload,
          datetime: execution.datetime,
          data: debuggingData
        }
      };

      return this.safeStringify({
        type: type,
        source: 'ft',
        version: this.version,
        data: data
      });
    }
  }, {
    key: 'Provider',
    value: function Provider() {
      var sendExecutionData = this.sendExecutionData.bind(this);

      return new _Provider({
        send: function send(data) {
          sendExecutionData(data, this.context.execution, this.context.functionDetails, this.context.props);
        },
        wrapProvider: function wrapProvider(name, provider) {
          var _this3 = this;

          return Object.keys(provider).reduce(function (wrappedProvider, key) {
            var originalFunc = provider[key];

            wrappedProvider[key] = function () {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              _this3.context.debugger.send({
                method: name + '.' + key,
                args: args
              });

              return originalFunc.apply(provider, args);
            };

            return wrappedProvider;
          }, {});
        }
      }, {
        wrap: false
      });
    }
  }]);

  return Devtools;
}(DevtoolsBase);

export default Devtools;
//# sourceMappingURL=index.js.map