{"version":3,"sources":["../src/executeTree.js"],"names":["executeTree","isPrimitive","primitive","type","_functionTreePrimitive","execution","initialPayload","executeBranchWrapper","branchStart","branchEnd","parallelStart","parallelProgress","parallelEnd","end","runBranch","branch","index","payload","prevPayload","nextBranch","runNextItem","result","processFunctionOutput","funcDetails","outputResult","newPayload","Object","assign","outputs","keys","indexOf","path","items","FunctionTreeExecutionError","name","join","currentItem","staticTree","itemLength","length","payloads","forEach","func","function","runFunction","push","apply","concat"],"mappings":"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","file":"executeTree.js","sourcesContent":["import { FunctionTreeExecutionError } from './errors'\n\nfunction isPrimitive(primitive, type) {\n  return primitive._functionTreePrimitive && primitive.type === type\n}\n\n/*\n  Runs through the tree providing a \"next\" callback to process next step\n  of execution\n*/\nexport default function executeTree(\n  execution,\n  initialPayload,\n  executeBranchWrapper,\n  branchStart,\n  branchEnd,\n  parallelStart,\n  parallelProgress,\n  parallelEnd,\n  end\n) {\n  function runBranch(branch, index, payload, prevPayload, nextBranch) {\n    executeBranchWrapper(() => {\n      function runNextItem(result) {\n        runBranch(branch, index + 1, result, payload, nextBranch)\n      }\n\n      function processFunctionOutput(funcDetails, outputResult) {\n        return function(result) {\n          const newPayload = Object.assign(\n            {},\n            payload,\n            result ? result.payload : {}\n          )\n\n          if (result && funcDetails.outputs) {\n            const outputs = Object.keys(funcDetails.outputs)\n\n            if (~outputs.indexOf(result.path)) {\n              branchStart(funcDetails, result.path, newPayload)\n              runBranch(\n                funcDetails.outputs[result.path].items,\n                0,\n                newPayload,\n                payload,\n                outputResult\n              )\n            } else {\n              throw new FunctionTreeExecutionError(\n                execution,\n                funcDetails,\n                payload,\n                `function ${\n                  funcDetails.name\n                } must use one of its possible outputs: ${outputs.join(', ')}.`\n              )\n            }\n          } else {\n            outputResult(newPayload)\n          }\n        }\n      }\n\n      const currentItem = branch[index]\n\n      if (!currentItem) {\n        if (branch !== execution.staticTree) {\n          branchEnd(payload)\n        }\n        nextBranch(payload)\n      } else if (isPrimitive(currentItem, 'sequence')) {\n        runBranch(currentItem.items, 0, payload, prevPayload, runNextItem)\n      } else if (isPrimitive(currentItem, 'parallel')) {\n        const itemLength = currentItem.items.length\n        const payloads = []\n\n        parallelStart(payload, itemLength)\n        currentItem.items.forEach((func, index) => {\n          if (func.function) {\n            execution.runFunction(\n              func,\n              payload,\n              prevPayload,\n              processFunctionOutput(func, (payload) => {\n                payloads.push(payload)\n                if (payloads.length === itemLength) {\n                  parallelEnd(payload, itemLength)\n                  runNextItem(\n                    Object.assign.apply(Object, [{}].concat(payloads))\n                  )\n                } else {\n                  parallelProgress(payload, itemLength - payloads.length)\n                }\n              })\n            )\n          } else {\n            runBranch(func.items, 0, payload, prevPayload, function(payload) {\n              payloads.push(payload)\n              if (payloads.length === itemLength) {\n                parallelEnd(payload, itemLength)\n                runNextItem(Object.assign.apply(Object, [{}].concat(payloads)))\n              } else {\n                parallelProgress(payload, itemLength - payloads.length)\n              }\n            })\n          }\n\n          return payloads\n        })\n      } else {\n        execution.runFunction(\n          currentItem,\n          payload,\n          prevPayload,\n          processFunctionOutput(currentItem, runNextItem)\n        )\n      }\n    })\n  }\n\n  runBranch([execution.staticTree], 0, initialPayload, null, end)\n}\n"]}