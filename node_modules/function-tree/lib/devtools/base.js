'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DevtoolsBase = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Path = require('../Path');

var _Path2 = _interopRequireDefault(_Path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DevtoolsBase = exports.DevtoolsBase = function () {
  function DevtoolsBase() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$https = _ref.https,
        https = _ref$https === undefined ? false : _ref$https,
        _ref$host = _ref.host,
        host = _ref$host === undefined ? null : _ref$host,
        _ref$reconnect = _ref.reconnect,
        reconnect = _ref$reconnect === undefined ? true : _ref$reconnect,
        _ref$reconnectInterva = _ref.reconnectInterval,
        reconnectInterval = _ref$reconnectInterva === undefined ? 10000 : _ref$reconnectInterva;

    _classCallCheck(this, DevtoolsBase);

    this.host = host;
    this.https = https;
    this.version = 0;
    if (!this.host) {
      throw new Error('Devtools: You have to pass in the "host" option');
    }
    this.backlog = [];
    this.isConnected = false;
    this.ws = null;
    this.reconnectInterval = reconnectInterval;
    this.doReconnect = reconnect;

    this.sendInitial = this.sendInitial.bind(this);
  }

  _createClass(DevtoolsBase, [{
    key: 'createSocket',
    value: function createSocket() {
      throw new Error('You have to implement a "createSocket" method');
    }
    /*
      Sets up the listeners to Chrome Extension or remote debugger
    */

  }, {
    key: 'addListeners',
    value: function addListeners() {
      this.createSocket();
      this.ws.onmessage = this.onMessage.bind(this);
    }
  }, {
    key: 'onMessage',
    value: function onMessage(event) {}
  }, {
    key: 'reconnect',
    value: function reconnect() {
      var _this = this;

      setTimeout(function () {
        _this.init();
      }, this.reconnectInterval);
    }
    /*
      The debugger might be ready or it might not. The initial communication
      with the debugger requires a "ping" -> "pong" to identify that it
      is ready to receive messages.
      1. Debugger is open when app loads
        - Devtools sends "ping"
        - Debugger sends "pong"
        - Devtools sends "init"
      2. Debugger is opened after app load
        - Debugger sends "ping"
        - Devtools sends "init"
    */

  }, {
    key: 'init',
    value: function init() {
      var _this2 = this;

      this.addListeners();
      this.ws.onopen = function () {
        _this2.ws.send(JSON.stringify({ type: 'ping' }));
      };
      this.ws.onerror = function () {};
      this.ws.onclose = function () {
        _this2.isConnected = false;

        if (_this2.doReconnect) {
          console.warn('Debugger application is not running on selected port... will reconnect automatically behind the scenes');
          _this2.reconnect();
        }
      };
    }
    /*
      Sends message to chrome extension or remote debugger
    */

  }, {
    key: 'sendMessage',
    value: function sendMessage(stringifiedMessage) {
      this.ws.send(stringifiedMessage);
    }
    /*
      Sends multiple message in one batch to debugger, causing debugger
      also to synchronously run all updates before rendering
    */

  }, {
    key: 'sendBulkMessage',
    value: function sendBulkMessage(messages, source) {
      var message = JSON.stringify({
        type: 'bulk',
        source: source,
        version: this.version,
        data: {
          messages: messages
        }
      });

      this.sendMessage(message);
    }
    /*
      Watches function tree for execution of signals. This is passed to
      debugger to prevent time travelling when executing. It also tracks
      latest executed signal for "remember" to know when signals can be
      called again
    */

  }, {
    key: 'watchExecution',
    value: function watchExecution(tree, source) {
      var _this3 = this;

      tree.on('start', function (execution, payload) {
        var message = JSON.stringify({
          type: 'executionStart',
          source: source,
          version: _this3.version,
          data: {
            execution: {
              executionId: execution.id,
              name: execution.name,
              staticTree: execution.staticTree,
              datetime: execution.datetime,
              executedBy: payload && payload._execution ? payload._execution : null
            }
          }
        });

        _this3.sendExecutionMessage(message);
      });
      tree.on('end', function (execution) {
        var message = JSON.stringify({
          type: 'executionEnd',
          source: source,
          version: _this3.version,
          data: {
            execution: {
              executionId: execution.id
            }
          }
        });
        _this3.latestExecutionId = execution.id;

        _this3.sendExecutionMessage(message);
      });
      tree.on('pathStart', function (path, execution, funcDetails) {
        var message = JSON.stringify({
          type: 'executionPathStart',
          source: source,
          version: _this3.version,
          data: {
            execution: {
              executionId: execution.id,
              functionIndex: funcDetails.functionIndex,
              path: path
            }
          }
        });

        _this3.sendExecutionMessage(message);
      });
      tree.on('functionStart', function (execution, funcDetails, payload) {
        var message = _this3.safeStringify({
          type: 'execution',
          source: source,
          version: _this3.version,
          data: {
            execution: {
              executionId: execution.id,
              functionIndex: funcDetails.functionIndex,
              payload: payload,
              data: null
            }
          }
        });

        _this3.sendExecutionMessage(message);
      });
      tree.on('functionEnd', function (execution, funcDetails, payload, result) {
        if (!result || result instanceof _Path2.default && !result.payload) {
          return;
        }

        var message = _this3.safeStringify({
          type: 'executionFunctionEnd',
          source: source,
          version: _this3.version,
          data: {
            execution: {
              executionId: execution.id,
              functionIndex: funcDetails.functionIndex,
              output: result instanceof _Path2.default ? result.payload : result
            }
          }
        });

        _this3.sendExecutionMessage(message);
      });
      tree.on('error', function (error, execution, funcDetails) {
        var message = JSON.stringify({
          type: 'executionFunctionError',
          source: source,
          version: _this3.version,
          data: {
            execution: {
              executionId: execution.id,
              functionIndex: funcDetails.functionIndex,
              error: {
                name: error.name,
                message: error.message,
                stack: error.stack,
                func: funcDetails.function.toString()
              }
            }
          }
        });

        _this3.sendExecutionMessage(message);
      });
    }
  }, {
    key: 'safeStringify',
    value: function safeStringify(object) {
      var refs = [];

      return JSON.stringify(object, function (key, value) {
        var isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && !Array.isArray(value);

        if (isObject && refs.indexOf(value) > -1) {
          return '[CIRCULAR]';
        } else if (isObject) {
          refs.push(value);
        }

        return value;
      });
    }
  }, {
    key: 'sendExecutionMessage',
    value: function sendExecutionMessage(message) {
      if (this.isConnected) {
        this.sendMessage(message);
      } else {
        this.backlog.push(message);
      }
    }
  }, {
    key: 'sendInitial',
    value: function sendInitial() {}
  }, {
    key: 'createExecutionMessage',
    value: function createExecutionMessage(debuggingData, execution, functionDetails, payload) {}
    /*
      Sends execution data to the debugger. Whenever a signal starts
      it will send a message to the debugger, but any functions in the
      function tree might also use this to send debugging data. Like when
      mutations are done or any wrapped methods run.
    */

  }, {
    key: 'sendExecutionData',
    value: function sendExecutionData(debuggingData, execution, functionDetails, payload) {
      var message = this.createExecutionMessage(debuggingData, execution, functionDetails, payload);

      this.sendExecutionMessage(message);
    }
  }]);

  return DevtoolsBase;
}();

exports.default = DevtoolsBase;
//# sourceMappingURL=base.js.map