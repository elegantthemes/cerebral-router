{"version":3,"sources":["../src/Tag.js"],"names":["createTemplateTag","Tag","type","getter","strings","values","concat","getNestedTags","context","reduce","currentPath","string","idx","valueTemplate","ResolveValue","getValue","undefined","getPath","currentPaths","pathToString","toString","tag","some","value","Error"],"mappings":";;;;;;;;;QAiFgBA,iB,GAAAA,iB;;AAjFhB;;;;;;;;AAEA;;;IAGaC,G,WAAAA,G;;;AACX,eAAYC,IAAZ,EAAkBC,MAAlB,EAA0BC,OAA1B,EAAmCC,MAAnC,EAA2C;AAAA;;AAAA;;AAEzC,UAAKH,IAAL,GAAYA,IAAZ;AACA,UAAKC,MAAL,GAAcA,MAAd;AACA,UAAKC,OAAL,GAAeA,OAAf;AACA,UAAKC,MAAL,GAAcA,MAAd;AALyC;AAM1C;AACD;;;;;;;;8BAIU;AACR,aAAO,CAAC,IAAD,EAAOC,MAAP,CAAc,KAAKC,aAAL,EAAd,CAAP;AACD;AACD;;;;;;4BAGQC,O,EAAS;AAAA;;AACf,aAAO,KAAKJ,OAAL,CAAaK,MAAb,CAAoB,UAACC,WAAD,EAAcC,MAAd,EAAsBC,GAAtB,EAA8B;AACvD,YAAMC,gBAAgB,OAAKR,MAAL,CAAYO,GAAZ,CAAtB;;AAEA,YAAIC,yBAAyBC,2BAA7B,EAA2C;AACzC,iBAAOJ,cAAcC,MAAd,GAAuBE,cAAcE,QAAd,CAAuBP,OAAvB,CAA9B;AACD;;AAED,eACEE,cACAC,MADA,IAECE,kBAAkBG,SAAlB,GAA8BH,aAA9B,GAA8C,EAF/C,CADF;AAKD,OAZM,EAYJ,EAZI,CAAP;AAaD;;;6BACQL,O,EAAS;AAChB,aAAO,KAAKL,MAAL,CAAY,KAAKc,OAAL,CAAaT,OAAb,CAAZ,EAAmCA,OAAnC,CAAP;AACD;AACD;;;;;;oCAGgB;AAAA;;AACd,aAAO,KAAKJ,OAAL,CAAaK,MAAb,CAAoB,UAACS,YAAD,EAAeP,MAAf,EAAuBC,GAAvB,EAA+B;AACxD,YAAMC,gBAAgB,OAAKR,MAAL,CAAYO,GAAZ,CAAtB;;AAEA,YAAIC,yBAAyBZ,GAA7B,EAAkC;AAChC,iBAAOiB,aAAaZ,MAAb,CAAoBO,aAApB,CAAP;AACD;;AAED,eAAOK,YAAP;AACD,OARM,EAQJ,EARI,CAAP;AASD;AACD;;;;;;+BAGW;AACT,aAAO,KAAKhB,IAAL,GAAY,GAAZ,GAAkB,KAAKiB,YAAL,EAAlB,GAAwC,GAA/C;AACD;AACD;;;;;;mCAGe;AAAA;;AACb,aAAO,KAAKf,OAAL,CAAaK,MAAb,CAAoB,UAACC,WAAD,EAAcC,MAAd,EAAsBC,GAAtB,EAA8B;AACvD,YAAMC,gBAAgB,OAAKR,MAAL,CAAYO,GAAZ,CAAtB;;AAEA,YAAIC,yBAAyBZ,GAA7B,EAAkC;AAChC,iBAAOS,cAAcC,MAAd,GAAuB,IAAvB,GAA8BE,cAAcO,QAAd,EAA9B,GAAyD,GAAhE;AACD;;AAED,eACEV,cACAC,MADA,IAECE,kBAAkBG,SAAlB,GAA8BH,aAA9B,GAA8C,EAF/C,CADF;AAKD,OAZM,EAYJ,EAZI,CAAP;AAaD;;;;EAzEsBC,2B;;AA4ElB,SAASd,iBAAT,CAA2BqB,GAA3B,EAAgCN,QAAhC,EAA0C;AAC/C,SAAO,UAACX,OAAD,EAAwB;AAAA,sCAAXC,MAAW;AAAXA,YAAW;AAAA;;AAC7B,QAAIA,OAAOiB,IAAP,CAAY,UAACC,KAAD;AAAA,aAAWA,UAAUP,SAArB;AAAA,KAAZ,CAAJ,EAAiD;AAC/C,YAAM,IAAIQ,KAAJ,CACJ,kFADI,CAAN;AAGD;AACD,WAAO,IAAIvB,GAAJ,CAAQoB,GAAR,EAAaN,QAAb,EAAuBX,OAAvB,EAAgCC,MAAhC,CAAP;AACD,GAPD;AAQD","file":"Tag.js","sourcesContent":["import { ResolveValue } from './ResolveValue'\n\n/*\n  Creates tag for targetting things with a path in Cerebral\n*/\nexport class Tag extends ResolveValue {\n  constructor(type, getter, strings, values) {\n    super()\n    this.type = type\n    this.getter = getter\n    this.strings = strings\n    this.values = values\n  }\n  /*\n    Returns all tags, also nested to identify nested state dependencies\n    in components\n  */\n  getTags() {\n    return [this].concat(this.getNestedTags())\n  }\n  /*\n    Gets the path of the tag, where nested tags are evaluated\n  */\n  getPath(context) {\n    return this.strings.reduce((currentPath, string, idx) => {\n      const valueTemplate = this.values[idx]\n\n      if (valueTemplate instanceof ResolveValue) {\n        return currentPath + string + valueTemplate.getValue(context)\n      }\n\n      return (\n        currentPath +\n        string +\n        (valueTemplate !== undefined ? valueTemplate : '')\n      )\n    }, '')\n  }\n  getValue(context) {\n    return this.getter(this.getPath(context), context)\n  }\n  /*\n    Grab nested tags from the tags current path\n  */\n  getNestedTags() {\n    return this.strings.reduce((currentPaths, string, idx) => {\n      const valueTemplate = this.values[idx]\n\n      if (valueTemplate instanceof Tag) {\n        return currentPaths.concat(valueTemplate)\n      }\n\n      return currentPaths\n    }, [])\n  }\n  /*\n    Produces a string representation of the tag\n  */\n  toString() {\n    return this.type + '`' + this.pathToString() + '`'\n  }\n  /*\n    Produces a string representation of the path\n  */\n  pathToString() {\n    return this.strings.reduce((currentPath, string, idx) => {\n      const valueTemplate = this.values[idx]\n\n      if (valueTemplate instanceof Tag) {\n        return currentPath + string + '${' + valueTemplate.toString() + '}'\n      }\n\n      return (\n        currentPath +\n        string +\n        (valueTemplate !== undefined ? valueTemplate : '')\n      )\n    }, '')\n  }\n}\n\nexport function createTemplateTag(tag, getValue) {\n  return (strings, ...values) => {\n    if (values.some((value) => value === undefined)) {\n      throw new Error(\n        'One of the values passed inside the tag interpolated to undefined. Please check.'\n      )\n    }\n    return new Tag(tag, getValue, strings, values)\n  }\n}\n"]}