function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { Provider } from '../';

export default function RecorderProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var timeout = options.setTimeout || setTimeout;

  // We will override the origin runSignal method to block
  // signals from running while playing back recording
  var originalRunSignal = null;
  var allowedSignals = [];
  var currentRecording = null;
  var currentSeek = 0;
  var currentEventIndex = 0;
  var lastEventTimestamp = 0;
  var nextEventTimeout = null;
  var started = null;
  var ended = null;
  var isPlaying = false;
  var _isRecording = false;

  function onFlush() {
    if (_isRecording) {
      currentRecording.events.push({
        type: 'flush',
        timestamp: Date.now()
      });
    }
  }

  function onMutation(_ref) {
    var method = _ref.method,
        path = _ref.path,
        args = _ref.args;

    currentRecording.events.push({
      type: 'mutation',
      method: method,
      args: JSON.stringify([path].concat(_toConsumableArray(args))),
      timestamp: Date.now()
    });
  }

  function addExternalEvent(type, data) {
    currentRecording.events.push({
      type: type,
      timestamp: Date.now(),
      data: data
    });
  }

  function updateDebugger(method, path, args, context) {
    if (context.debugger && typeof window !== 'undefined' && window.CustomEvent) {
      var event = new window.CustomEvent('cerebral2.client.message', {
        detail: JSON.stringify({
          type: 'recorderMutation',
          data: {
            method: method,
            path: path,
            args: args
          }
        })
      });
      window.dispatchEvent(event);
    }
  }

  function mutate(mutation, context) {
    var args = JSON.parse(mutation.args);
    var path = args.shift();

    context.controller.model[mutation.method].apply(context.controller.model, [path].concat(args));
    updateDebugger(mutation.method, path, args, context);
  }

  // During playback we run events as they were recorded, one after
  // the other
  function runNextEvent(context) {
    var event = currentRecording.events[currentEventIndex];

    nextEventTimeout = timeout(function () {
      if (event.type === 'mutation') {
        mutate(event, context);
      } else if (event.type === 'flush') {
        context.controller.flush();
      } else {
        context.controller.emit(event.type, event.data);
      }

      lastEventTimestamp = event.timestamp;
      currentEventIndex++;

      if (!currentRecording.events[currentEventIndex]) {
        context.controller.runSignal = originalRunSignal;
        isPlaying = false;
        currentEventIndex = 0;

        return;
      }

      runNextEvent(context);
    }, event.timestamp - lastEventTimestamp);
  }

  function resetState(context) {
    currentRecording.initialState.forEach(function (state) {
      var value = JSON.parse(state.value);

      context.controller.model.set(state.path, value);
      updateDebugger('set', state.path, [value], context);
    });
    for (var x = 0; x < currentEventIndex; x++) {
      if (currentRecording.events[x].type === 'mutation') {
        mutate(currentRecording.events[x], context);
      }
    }
  }

  return Provider({
    seek: function seek(_seek) {
      clearTimeout(nextEventTimeout);

      for (var x = 0; x < currentRecording.events.length; x++) {
        currentEventIndex = x;

        var event = currentRecording.events[x];
        if (event.timestamp - currentRecording.start > _seek) {
          break;
        }
      }

      resetState(this.context);
      this.context.controller.emit('recorder:seek', _seek);
    },
    play: function play() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (isPlaying || _isRecording) {
        throw new Error('CEREBRAL Recorder - You can not play while already playing or recording');
      }

      allowedSignals = options.allowedSignals || [];
      resetState(this.context);
      isPlaying = true;
      started = Date.now();
      lastEventTimestamp = currentRecording.start;

      originalRunSignal = this.context.controller.runSignal;
      this.context.controller.runSignal = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (allowedSignals.indexOf(args[0]) >= 0) {
          originalRunSignal.apply(_this.context.controller, args);
        }
      };
      this.context.controller.flush(true);
      runNextEvent(this.context);
      this.context.controller.emit('recorder:play', currentSeek, options);
    },
    record: function record() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // If we are recording over the previous stuff, go back to start
      if (currentRecording) {
        currentSeek = 0;
        ended = null;
      }

      var paths = options.initialState || [''];
      var state = paths.map(function (path) {
        var arrayPath = path ? path.split('.') : [];

        return {
          path: arrayPath,
          value: JSON.stringify(_this2.context.controller.getState(arrayPath))
        };
      });

      currentRecording = {
        initialState: state,
        start: Date.now(),
        events: []
      };

      this.context.controller.on('recorder:event', addExternalEvent);

      _isRecording = true;
      this.context.controller.emit('recorder:record', options);

      // We need to record flush events to update the UI
      // at the same time as during the recording
      this.context.controller.on('flush', onFlush);
      this.context.controller.on('mutation', onMutation);

      originalRunSignal = this.context.controller.runSignal;
    },
    stop: function stop() {
      var wasPlaying = isPlaying;
      clearTimeout(nextEventTimeout);
      isPlaying = false;
      _isRecording = false;
      this.context.controller.runSignal = originalRunSignal;
      this.context.controller.off('recorder:event', addExternalEvent);

      if (wasPlaying) {
        return;
      }

      currentRecording.end = Date.now();
      currentEventIndex = 0;
      currentRecording.events.push({
        type: 'flush',
        timestamp: Date.now()
      });
      this.context.controller.emit('recorder:stop');
      this.context.controller.off('flush', onFlush);
      this.context.controller.off('mutation', onMutation);
    },
    pause: function pause() {
      ended = Date.now();
      currentSeek = ended - started;
      clearTimeout(nextEventTimeout);
      isPlaying = false;
      this.context.controller.emit('recorder:pause', currentSeek);
    },
    getRecording: function getRecording() {
      return currentRecording;
    },
    getCurrentSeek: function getCurrentSeek() {
      return currentSeek;
    },
    loadRecording: function loadRecording(recording) {
      currentRecording = recording;
    },
    isRecording: function isRecording() {
      return _isRecording;
    }
  });
}
//# sourceMappingURL=Recorder.js.map