var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { Controller } from '../';
import { Provider as FTProvider } from 'function-tree';
import { DevtoolsBase } from 'function-tree/devtools';
import { ensurePath } from '../utils';

var Action = function Action(name) {
  _classCallCheck(this, Action);

  this.name = name;
};

var Mutation = function Mutation(mutation) {
  _classCallCheck(this, Mutation);

  this.method = mutation.method;
  this.path = mutation.args.shift().join('.');
  this.args = mutation.args;
};

var Provider = function Provider(provider) {
  _classCallCheck(this, Provider);

  this.method = provider.method;
  this.args = provider.args;
};

var Path = function Path(name) {
  _classCallCheck(this, Path);

  this.name = name;
};

var SnapshotDevtool = function (_DevtoolsBase) {
  _inherits(SnapshotDevtool, _DevtoolsBase);

  function SnapshotDevtool() {
    _classCallCheck(this, SnapshotDevtool);

    return _possibleConstructorReturn(this, (SnapshotDevtool.__proto__ || Object.getPrototypeOf(SnapshotDevtool)).apply(this, arguments));
  }

  _createClass(SnapshotDevtool, [{
    key: 'createSocket',
    value: function createSocket() {
      this.isConnected = true;
      this.ws = {
        onopen: function onopen() {},
        onerror: function onerror() {},
        onclose: function onclose() {},
        send: function send() {}
      };
    }
  }, {
    key: 'createExecutionMessage',
    value: function createExecutionMessage(data, execution, functionDetails) {
      return {
        type: data.type || 'provider',
        functionIndex: functionDetails.functionIndex,
        method: data.method,
        args: data.args
      };
    }
  }, {
    key: 'updateComponentsMap',
    value: function updateComponentsMap() {}
  }]);

  return SnapshotDevtool;
}(DevtoolsBase);

var MockedProvider = function (_FTProvider) {
  _inherits(MockedProvider, _FTProvider);

  function MockedProvider(name, provider, mocks) {
    _classCallCheck(this, MockedProvider);

    var _this2 = _possibleConstructorReturn(this, (MockedProvider.__proto__ || Object.getPrototypeOf(MockedProvider)).call(this, {}));

    _this2.name = name;
    _this2.provider = provider;
    _this2.mocks = mocks;
    return _this2;
  }

  _createClass(MockedProvider, [{
    key: 'getWrapped',
    value: function getWrapped(providerName, context) {
      var _this3 = this;

      var definition = this.provider.WrappedProviderConstructor.prototype;
      return Object.keys(definition).reduce(function (mockedProvider, key) {
        mockedProvider[key] = function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          context.debugger.send({
            method: providerName + '.' + key,
            args: args
          });

          var nextMock = _this3.mocks.shift();

          if (!nextMock) {
            throw new Error('"' + _this3.name + '.' + key + '" was called, but there is no mock for it');
          }

          if (nextMock.path !== _this3.name + '.' + key) {
            throw new Error('The expected mock "' + nextMock.path + '" does not match "' + _this3.name + '.' + key + '"');
          }

          if (nextMock.isAsync) {
            return nextMock.isResolved ? Promise.resolve(nextMock.value) : Promise.reject(nextMock.value);
          }

          return nextMock.value;
        };

        return mockedProvider;
      }, {});
    }
  }]);

  return MockedProvider;
}(FTProvider);

var notWrappedProviders = ['state', 'resolve', 'module', 'debugger'];

var Snapshot = function () {
  function Snapshot(rootModule) {
    _classCallCheck(this, Snapshot);

    this.controller = Controller(rootModule, {
      devtools: new SnapshotDevtool({
        host: 'local'
      }),
      preventInitialize: true
    });
    this.controller.flush = function () {};
    this.mocks = [];
    this.execution = [];

    this.createMockedProviders();
  }

  _createClass(Snapshot, [{
    key: 'createMockedProviders',
    value: function createMockedProviders() {
      var _this4 = this;

      var providers = this.controller.contextProviders;

      this.controller.contextProviders = Object.keys(providers).reduce(function (wrappedProviders, provider) {
        if (providers[provider] instanceof FTProvider && notWrappedProviders.indexOf(provider) === -1) {
          wrappedProviders[provider] = new MockedProvider(provider, providers[provider], _this4.mocks);
        } else {
          wrappedProviders[provider] = providers[provider];
        }

        return wrappedProviders;
      }, {});
    }
  }, {
    key: 'mutate',
    value: function mutate(method, path) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      this.controller.model[method].apply(this.controller.model, [ensurePath(path)].concat(args));

      return this;
    }
  }, {
    key: 'mock',
    value: function mock(path, value) {
      this.mocks.push({ path: path, value: value });

      return this;
    }
  }, {
    key: 'mockResolvedPromise',
    value: function mockResolvedPromise(path, value) {
      this.mocks.push({ path: path, value: value, isAsync: true, isResolved: true });

      return this;
    }
  }, {
    key: 'mockRejectedPromise',
    value: function mockRejectedPromise(path, value) {
      this.mocks.push({ path: path, value: value, isAsync: true, isResolved: false });

      return this;
    }
  }, {
    key: 'run',
    value: function run(signalPath, payload) {
      var _this5 = this;

      if (this.staticTree) {
        throw new Error('You have already run this snapshot');
      }

      return new Promise(function (resolve, reject) {
        var pathArray = ensurePath(signalPath);
        var signalKey = pathArray.pop();
        var module = pathArray.reduce(function (currentModule, key) {
          return currentModule ? currentModule.modules[key] : undefined;
        }, _this5.controller.module);
        var signal = module && module.signals[signalKey];

        if (!signal) {
          throw new Error('The signal on path "' + signalPath + '" does not exist, please check path');
        }

        _this5.controller.devtools.ws.send = function (update) {
          if (update.type === 'mutation') {
            _this5.execution.push(new Mutation(update));
          } else if (update.type === 'provider') {
            _this5.execution.push(new Provider(update));
          }
        };

        _this5.controller.on('functionStart', function (execution, functionDetails) {
          _this5.execution.push(new Action(functionDetails.name));
        });

        _this5.controller.on('pathStart', function (name) {
          _this5.execution.push(new Path(name));
        });

        _this5.controller.run(signalPath, signal.signal, payload, function (error) {
          if (error) {
            reject(error);
          } else {
            resolve(_this5);
          }
        });
      });
    }
  }, {
    key: 'get',
    value: function get() {
      return this.execution;
    }
  }]);

  return Snapshot;
}();

export default (function (rootModule) {
  return new Snapshot(rootModule);
});
//# sourceMappingURL=snapshot.js.map