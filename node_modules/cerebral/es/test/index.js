export { _runSignal as runSignal };
import { Path, Primitive } from 'function-tree';
import { Controller, Module } from '..';
import { ensurePath, cleanPath } from '../utils';

export { default as Snapshot } from './snapshot';

export function runCompute(compute) {
  var fixtures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var response = void 0;
  var rootModule = Module({
    state: fixtures.state || {},
    signals: {
      test: [function (_ref) {
        var resolve = _ref.resolve;

        response = resolve.value(compute, fixtures.props);
      }]
    }
  });
  var controller = Controller(rootModule);
  controller.getSignal('test')(fixtures.props);

  return response;
}

function _runSignal(signal) {
  var fixtures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return new Promise(function (resolve, reject) {
    var recordActions = options.recordActions && options.recordActions === 'byName' ? 'name' : 'functionIndex';
    var isSignal = Array.isArray(signal) || signal instanceof Primitive;
    var controller = options.controller || Controller(Module(Object.assign({}, fixtures, isSignal && { signals: { signal: signal } })));
    var response = { controller: controller };

    var actionStart = function actionStart(execution, funcDetails, payload) {
      if (options.singleAction) {
        response.props = payload;
      } else {
        if (!options.noDuplicateWarnings && response[funcDetails[recordActions]]) {
          console.warn('Cerebral[runSignal]: signal contains actions with duplicate names (\'' + funcDetails[recordActions] + '\')');
        }
        response[funcDetails[recordActions]] = { props: payload };
      }
    };

    var actionEnd = function actionEnd(execution, funcDetails, payload, result) {
      if (!result || result instanceof Path && !result.payload) {
        return;
      }
      if (options.singleAction || response[funcDetails[recordActions]]) {
        var output = result instanceof Path ? result.payload : result;
        if (options.singleAction) {
          response.output = output;
        } else {
          response[funcDetails[recordActions]].output = output;
        }
      }
    };

    var error = function error(err) {
      off();
      reject(err);
    };

    var signalEnd = function signalEnd() {
      off();
      response.state = controller.getState();
      resolve(response);
    };

    var off = function off() {
      controller.off('functionStart', actionStart);
      controller.off('functionEnd', actionEnd);
      controller.off('error', error);
      controller.off('end', signalEnd);
    };

    controller.on('functionStart', actionStart);
    controller.on('functionEnd', actionEnd);
    controller.on('error', error);
    controller.on('end', signalEnd);
    controller.getSignal(isSignal ? 'signal' : signal)(fixtures.props);
  });
}

export function CerebralTest(rootModule) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { throwToConsole: false };

  var controller = Controller(rootModule, options);
  var model = controller.getModel();
  return {
    controller: controller,
    runSignal: function runSignal(signal, props) {
      return _runSignal(signal, { props: props }, Object.assign({}, options, { controller: controller, noDuplicateWarnings: true }));
    },
    setState: function setState(path, value) {
      model.set(ensurePath(cleanPath(path)), value);
      model.flush();
    },
    getState: function getState(path) {
      return model.get(ensurePath(cleanPath(path)));
    }
  };
}

export function runAction(action) {
  var fixtures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return _runSignal([action], fixtures, {
    recordActions: true,
    singleAction: true
  });
}
//# sourceMappingURL=index.js.map