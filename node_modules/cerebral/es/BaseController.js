var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import FunctionTree from 'function-tree';
import Module from './Module';
import { ensurePath, isDeveloping, throwError, isSerializable, forceSerializable, isObject, getProviders, getModule, cleanPath } from './utils';
import DebuggerProvider from './providers/Debugger';
import ModuleProvider from './providers/Module';

/*
  The controller is where everything is attached. The devtools
  is attached directly. Also a top level module is created.
  The controller creates the function tree that will run all signals,
  based on top level providers and providers defined in modules
*/

var BaseController = function (_FunctionTree) {
  _inherits(BaseController, _FunctionTree);

  function BaseController(rootModule, options, functionTreeOptions) {
    _classCallCheck(this, BaseController);

    var _this = _possibleConstructorReturn(this, (BaseController.__proto__ || Object.getPrototypeOf(BaseController)).call(this, {}, functionTreeOptions));

    var Model = options.Model,
        _options$devtools = options.devtools,
        devtools = _options$devtools === undefined ? null : _options$devtools,
        _options$stateChanges = options.stateChanges,
        stateChanges = _options$stateChanges === undefined ? typeof window !== 'undefined' && window.CEREBRAL_STATE : _options$stateChanges,
        _options$throwToConso = options.throwToConsole,
        throwToConsole = _options$throwToConso === undefined ? true : _options$throwToConso,
        _options$preventIniti = options.preventInitialize,
        preventInitialize = _options$preventIniti === undefined ? false : _options$preventIniti;

    var getSignal = _this.getSignal;
    var getSignals = _this.getSignals;

    _this.getSignal = function () {
      throwError('You are grabbing a signal before controller has initialized, please wait for "initialized" event');
    };

    _this.getSignals = function () {
      throwError('You are grabbing a signals before controller has initialized, please wait for "initialized" event');
    };

    if (!(rootModule instanceof Module)) {
      throwError('You did not pass a root module to the controller. The first argument has to be a module');
    }

    _this.throwToConsole = throwToConsole;

    _this.devtools = devtools;
    _this.module = rootModule.create(_this, []);
    _this.model = new Model(_this);

    if (!preventInitialize) {
      _this.emit('initialized:model');
    }

    _this.contextProviders = Object.assign(_this.contextProviders, getProviders(_this.module), {
      controller: _this,
      state: _this.model.StateProvider(_this.devtools),
      module: ModuleProvider(_this.devtools)
    }, _this.devtools ? {
      debugger: DebuggerProvider(_this.devtools)
    } : {});

    if (stateChanges) {
      Object.keys(stateChanges).forEach(function (statePath) {
        _this.model.set(ensurePath(statePath), stateChanges[statePath]);
      });
    }

    if (_this.devtools) {
      _this.devtools.init(_this);
    }

    if (!_this.devtools && isDeveloping() && typeof navigator !== 'undefined' && /Chrome/.test(navigator.userAgent)) {
      console.warn('You are not using the Cerebral devtools. It is highly recommended to use it in combination with the debugger: https://cerebraljs.com/docs/introduction/debugger.html');
    }

    if (isDeveloping()) {
      _this.on('functionStart', function (execution, functionDetails, payload) {
        try {
          JSON.stringify(payload);
        } catch (e) {
          throwError('The function ' + functionDetails.name + ' in signal ' + execution.name + ' is not given a valid payload');
        }
      });
      _this.on('functionEnd', function (execution, functionDetails, payload, propsToAdd) {
        if (devtools && devtools.preventPropsReplacement) {
          Object.keys(propsToAdd || {}).forEach(function (key) {
            if (key in payload) {
              throw new Error('Cerebral Devtools - You have activated the "preventPropsReplacement" option and in signal "' + execution.name + '", before the action "' + functionDetails.name + '", the key "' + key + '" was replaced');
            }
          });
        }
      });
    }

    _this.getSignal = getSignal;
    _this.getSignals = getSignals;

    if (!preventInitialize) {
      _this.emit('initialized');
    }
    return _this;
  }
  /*
    Conveniance method for grabbing the model
  */


  _createClass(BaseController, [{
    key: 'getModel',
    value: function getModel() {
      return this.model;
    }
    /*
      Method called by view to grab state
    */

  }, {
    key: 'getState',
    value: function getState(path) {
      return this.model.get(ensurePath(cleanPath(path)));
    }
    /*
      Uses function tree to run the array and optional
      payload passed in. The payload will be checkd
    */

  }, {
    key: 'runSignal',
    value: function runSignal(name, signal) {
      var _this2 = this;

      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (this.devtools && (!isObject(payload) || !isSerializable(payload))) {
        console.warn('You passed an invalid payload to signal "' + name + '". Only serializable payloads can be passed to a signal. The payload has been ignored. This is the object:', payload);
        payload = {};
      }

      if (this.devtools) {
        payload = Object.keys(payload).reduce(function (currentPayload, key) {
          if (!isSerializable(payload[key], _this2.devtools.allowedTypes)) {
            console.warn('You passed an invalid payload to signal "' + name + '", on key "' + key + '". Only serializable values like Object, Array, String, Number and Boolean can be passed in. Also these special value types:', _this2.devtools.allowedTypes);

            return currentPayload;
          }

          currentPayload[key] = forceSerializable(payload[key]);

          return currentPayload;
        }, {});
      }

      this.run(name, signal, payload, function (error) {
        if (error) {
          var signalPath = ensurePath(error.execution.name);
          var catchingResult = signalPath.reduce(function (details, key, index) {
            if (details.currentModule.catch) {
              details.catchingModule = details.currentModule;
            }

            details.currentModule = details.currentModule.modules[key];

            return details;
          }, {
            currentModule: _this2.module,
            catchingModule: null
          });

          if (catchingResult.catchingModule) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = catchingResult.catchingModule.catch[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2),
                    errorType = _step$value[0],
                    signalChain = _step$value[1];

                if (error instanceof errorType) {
                  _this2.runSignal('catch', signalChain, error.payload);

                  // Throw the error to console even if handling it
                  if (_this2.throwToConsole) {
                    setTimeout(function () {
                      console.log('Cerebral is handling error "' + error.name + ': ' + error.message + '" thrown by signal "' + error.execution.name + '". Check debugger for more information.');
                    });
                  }

                  return;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          if (error.execution.isAsync) {
            setTimeout(function () {
              throw error;
            });
          } else {
            throw error;
          }
        }
      });
    }
    /*
      Returns a function which binds the name/path of signal,
      and the array. This allows view layer to just call it with
      an optional payload and it will run
    */

  }, {
    key: 'getSignal',
    value: function getSignal(path) {
      var pathArray = ensurePath(path);
      var signalKey = pathArray.pop();
      var module = pathArray.reduce(function (currentModule, key) {
        return currentModule ? currentModule.modules[key] : undefined;
      }, this.module);
      var signal = module && module.signals[signalKey];

      if (!signal) {
        throwError('The signal on path "' + path + '" does not exist, please check path');
      }

      return signal && signal.run;
    }
  }, {
    key: 'getSignals',
    value: function getSignals(modulePath) {
      var pathArray = ensurePath(modulePath);
      var module = pathArray.reduce(function (currentModule, key) {
        return currentModule ? currentModule.modules[key] : undefined;
      }, this.module);

      var signals = module && module.signals;

      if (!signals) {
        return undefined;
      }

      var callableSignals = {};
      for (var name in signals) {
        var signal = signals[name].run;
        callableSignals[name] = signal;
      }

      return callableSignals;
    }
  }, {
    key: 'addModule',
    value: function addModule(path, module) {
      var pathArray = ensurePath(path);
      var moduleKey = pathArray.pop();
      var parentModule = getModule(pathArray, this.module);
      var newModule = module.create(this, ensurePath(path));
      parentModule.modules[moduleKey] = newModule;

      if (newModule.providers) {
        Object.assign(this.contextProviders, newModule.providers);
      }

      this.emit('moduleAdded', path.split('.'), newModule);

      this.flush();
    }
  }, {
    key: 'removeModule',
    value: function removeModule(path) {
      var _this3 = this;

      if (!path) {
        console.warn('Controller.removeModule requires a Module Path');
        return null;
      }

      var pathArray = ensurePath(path);
      var moduleKey = pathArray.pop();
      var parentModule = getModule(pathArray, this.module);

      var module = parentModule.modules[moduleKey];

      if (module.providers) {
        Object.keys(module.providers).forEach(function (provider) {
          delete _this3.contextProviders[provider];
        });
      }

      delete parentModule.modules[moduleKey];

      this.emit('moduleRemoved', ensurePath(path), module);

      this.flush();
    }
  }]);

  return BaseController;
}(FunctionTree);

export default BaseController;
//# sourceMappingURL=BaseController.js.map