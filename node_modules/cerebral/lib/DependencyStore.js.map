{"version":3,"sources":["../src/DependencyStore.js"],"names":["DependencyStore","map","entity","depsMap","depsMapKey","path","split","reduce","currentMapLevel","key","index","length","children","entities","concat","splice","indexOf","prevDepsMap","nextDepsMap","toRemove","Object","keys","removeDepsMap","prevDepsMapKey","toAdd","addDepsMap","nextDepsMapKey","removeEntity","addEntity","traverseChildren","childKey","y","push","changesMap","unique","match","currentUnique"],"mappings":"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","file":"DependencyStore.js","sourcesContent":["import { dependencyMatch } from './utils'\n\nclass DependencyStore {\n  constructor() {\n    this.map = {}\n  }\n  /*\n    Adds the entity to all the depending paths\n  */\n  addEntity(entity, depsMap) {\n    for (const depsMapKey in depsMap) {\n      const path = depsMapKey.split('.')\n\n      path.reduce((currentMapLevel, key, index) => {\n        if (!currentMapLevel[key]) {\n          currentMapLevel[key] = {}\n        }\n\n        if (index < path.length - 1) {\n          currentMapLevel[key].children = currentMapLevel[key].children || {}\n\n          return currentMapLevel[key].children\n        }\n\n        currentMapLevel[key].entities = currentMapLevel[key].entities\n          ? currentMapLevel[key].entities.concat(entity)\n          : [entity]\n\n        return currentMapLevel\n      }, this.map)\n    }\n  }\n  /*\n    Removes the entity from all depending paths\n  */\n  removeEntity(entity, depsMap) {\n    for (const depsMapKey in depsMap) {\n      const path = depsMapKey.split('.')\n      path.reduce((currentMapLevel, key, index) => {\n        if (index === path.length - 1) {\n          currentMapLevel[key].entities.splice(\n            currentMapLevel[key].entities.indexOf(entity),\n            1\n          )\n\n          if (!currentMapLevel[key].entities.length) {\n            delete currentMapLevel[key].entities\n          }\n        }\n\n        return currentMapLevel[key].children\n      }, this.map)\n    }\n  }\n  /*\n    Updates entity based on changed dependencies\n  */\n  updateEntity(entity, prevDepsMap, nextDepsMap) {\n    const toRemove = Object.keys(prevDepsMap).reduce(\n      (removeDepsMap, prevDepsMapKey) => {\n        if (!nextDepsMap[prevDepsMapKey]) {\n          removeDepsMap[prevDepsMapKey] = true\n        }\n\n        return removeDepsMap\n      },\n      {}\n    )\n    const toAdd = Object.keys(nextDepsMap).reduce(\n      (addDepsMap, nextDepsMapKey) => {\n        if (!prevDepsMap[nextDepsMapKey]) {\n          addDepsMap[nextDepsMapKey] = true\n        }\n\n        return addDepsMap\n      },\n      {}\n    )\n\n    this.removeEntity(entity, toRemove)\n\n    this.addEntity(entity, toAdd)\n  }\n  /*\n    As same entity can appear in multiple paths, this method returns\n    all unique entities. Used by view to render all components\n  */\n  getAllUniqueEntities() {\n    const entities = []\n\n    function traverseChildren(children) {\n      for (const childKey in children) {\n        if (children[childKey].entities) {\n          for (let y = 0; y < children[childKey].entities.length; y++) {\n            if (entities.indexOf(children[childKey].entities[y]) === -1) {\n              entities.push(children[childKey].entities[y])\n            }\n          }\n        }\n\n        if (children[childKey].children) {\n          traverseChildren(children[childKey].children)\n        }\n      }\n    }\n    traverseChildren(this.map)\n\n    return entities\n  }\n  /*\n    Returns entities based on a change map returned from\n    the model flush method.\n  */\n  getUniqueEntities(changesMap) {\n    return dependencyMatch(changesMap, this.map).reduce((unique, match) => {\n      return (match.entities || []).reduce((currentUnique, entity) => {\n        if (currentUnique.indexOf(entity) === -1) {\n          return currentUnique.concat(entity)\n        }\n\n        return currentUnique\n      }, unique)\n    }, [])\n  }\n}\n\nexport default DependencyStore\n"]}