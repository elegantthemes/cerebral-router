'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _BaseModel2 = require('./BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Model = function (_BaseModel) {
  _inherits(Model, _BaseModel);

  function Model(controller) {
    _classCallCheck(this, Model);

    var _this = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this, controller));

    _this.controller = controller;
    _this.devtools = controller.devtools;
    _this.state = _this.devtools && _this.devtools.warnStateProps ? (0, _utils.addCerebralStateKey)(_this.initialState) : _this.initialState;

    controller.on('initialized', function () {
      _this.flush();
    });
    return _this;
  }

  _createClass(Model, [{
    key: 'updateIn',
    value: function updateIn(path, cb) {
      var _this2 = this;

      var forceChildPathUpdates = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!path.length) {
        cb(this.state, this, 'state');

        return;
      }

      path.reduce(function (currentState, key, index) {
        if (index === path.length - 1) {
          if (!Array.isArray(currentState) && !(0, _utils.isObject)(currentState)) {
            (0, _utils.throwError)('The path "' + path.join('.') + '" is invalid. Path: "' + path.slice(0, path.length - 1).join('.') + '" is type of "' + (currentState === null ? 'null' : typeof currentState === 'undefined' ? 'undefined' : _typeof(currentState)) + '"');
          }

          var currentValue = currentState[key];

          cb(currentState[key], currentState, key);
          if (currentState[key] !== currentValue || (0, _utils.isComplexObject)(currentState[key]) && (0, _utils.isComplexObject)(currentValue)) {
            _this2.changedPaths.push({
              path: path,
              forceChildPathUpdates: forceChildPathUpdates
            });
          }
        } else if (!currentState[key]) {
          currentState[key] = {};
        }

        return currentState[key];
      }, this.state);
    }
  }, {
    key: 'verifyValue',
    value: function verifyValue(value, path) {
      if (this.devtools && !(0, _utils.isSerializable)(value, this.devtools.allowedTypes)) {
        (0, _utils.throwError)('You are passing a non serializable value into the state tree on path "' + path.join('.') + '"');
      }
      if (this.devtools) {
        (0, _utils.forceSerializable)(value);
      }
      if (this.devtools && this.devtools.warnStateProps) {
        (0, _utils.addCerebralStateKey)(value);
      }
    }
  }, {
    key: 'verifyValues',
    value: function verifyValues(values, path) {
      var _this3 = this;

      if (this.devtools) {
        values.forEach(function (value) {
          _this3.verifyValue(value, path);
        });
      }
    }
  }, {
    key: 'emitMutationEvent',
    value: function emitMutationEvent(method, path) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.controller.emit('mutation', {
        method: method,
        path: path,
        args: args
      });
    }
  }, {
    key: 'get',
    value: function get() {
      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return path.reduce(function (currentState, key) {
        return currentState ? currentState[key] : undefined;
      }, this.state);
    }
  }, {
    key: 'set',
    value: function set(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (_, parent, key) {
        parent[key] = value;
      }, true);
      this.emitMutationEvent('set', path, value);
    }
  }, {
    key: 'toggle',
    value: function toggle(path) {
      this.updateIn(path, function (value, parent, key) {
        parent[key] = !value;
      });
      this.emitMutationEvent('toggle', path);
    }
  }, {
    key: 'push',
    value: function push(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (array) {
        array.push(value);
      });
      this.emitMutationEvent('push', path, value);
    }
  }, {
    key: 'merge',
    value: function merge(path) {
      for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      var value = Object.assign.apply(Object, values);

      // If we already have an object we make it behave
      // like multiple sets, indicating a change to very key.
      // If no value it should indicate that we are setting
      // a new object
      if (this.get(path)) {
        for (var prop in value) {
          this.set(path.concat(prop), value[prop]);
        }
      } else {
        this.set(path, value);
      }
      this.emitMutationEvent.apply(this, ['merge', path].concat(values));
    }
  }, {
    key: 'pop',
    value: function pop(path) {
      this.updateIn(path, function (array) {
        array.pop();
      });
      this.emitMutationEvent('pop', path);
    }
  }, {
    key: 'shift',
    value: function shift(path) {
      this.updateIn(path, function (array) {
        array.shift();
      });
      this.emitMutationEvent('shift', path);
    }
  }, {
    key: 'unshift',
    value: function unshift(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (array) {
        array.unshift(value);
      });
      this.emitMutationEvent('unshift', path, value);
    }
  }, {
    key: 'splice',
    value: function splice(path) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      this.verifyValues(args, path);
      this.updateIn(path, function (array) {
        array.splice.apply(array, args);
      });
      this.emitMutationEvent.apply(this, ['splice', path].concat(args));
    }
  }, {
    key: 'unset',
    value: function unset(path) {
      this.updateIn(path, function (_, parent, key) {
        delete parent[key];
      }, true);
      this.emitMutationEvent('unset', path);
    }
  }, {
    key: 'concat',
    value: function concat(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (array, parent, key) {
        parent[key] = array.concat(value);
      });
      this.emitMutationEvent('concat', path, value);
    }
  }, {
    key: 'increment',
    value: function increment(path) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      if (!Number.isInteger(delta)) {
        throw new Error('Cerebral state.increment: you must increment with integer values.');
      }
      this.updateIn(path, function (value, parent, key) {
        if (!Number.isInteger(value)) {
          throw new Error('Cerebral state.increment: you must increment integer values.');
        }
        parent[key] = value + delta;
      });
      this.emitMutationEvent('increment', path, delta);
    }
  }]);

  return Model;
}(_BaseModel3.default);

exports.default = Model;
//# sourceMappingURL=Model.js.map