'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noop = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getChangedProps = getChangedProps;
exports.cleanPath = cleanPath;
exports.isObject = isObject;
exports.isComplexObject = isComplexObject;
exports.isSerializable = isSerializable;
exports.ensurePath = ensurePath;
exports.throwError = throwError;
exports.isDeveloping = isDeveloping;
exports.delay = delay;
exports.forceSerializable = forceSerializable;
exports.getProviders = getProviders;
exports.dependencyMatch = dependencyMatch;
exports.getWithPath = getWithPath;
exports.ensureStrictPath = ensureStrictPath;
exports.createResolver = createResolver;
exports.createDummyController = createDummyController;
exports.addCerebralStateKey = addCerebralStateKey;
exports.getStateTreeProp = getStateTreeProp;
exports.getModule = getModule;
exports.extractModuleProp = extractModuleProp;

var _tags = require('./tags');

var _Compute = require('./Compute');

function getChangedProps() {
  var propsA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var propsB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var propsAKeys = Object.keys(propsA);
  var propsBKeys = Object.keys(propsB);
  var changedProps = [];

  for (var i = 0; i < propsAKeys.length; i++) {
    if (propsA[propsAKeys[i]] !== propsB[propsAKeys[i]]) {
      changedProps.push({ path: [propsAKeys[i]] });
    }
  }

  for (var _i = 0; _i < propsBKeys.length; _i++) {
    if (propsA[propsBKeys[_i]] !== propsB[propsBKeys[_i]]) {
      changedProps.push({ path: [propsBKeys[_i]] });
    }
  }

  return changedProps;
}

function cleanPath(path) {
  return typeof path === 'string' ? path.replace(/\.\*\*|\.\*/, '') : path;
}

function isObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null && !Array.isArray(obj);
}

function isComplexObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null;
}

function isSerializable(value) {
  var additionalTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var validType = additionalTypes.reduce(function (currentValid, type) {
    if (currentValid || value instanceof type) {
      return true;
    }

    return currentValid;
  }, false);

  if (value !== undefined && (validType || isObject(value) && Object.prototype.toString.call(value) === '[object Object]' && (value.constructor === Object || Object.getPrototypeOf(value) === null) || typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean' || value === null || Array.isArray(value))) {
    return true;
  }
  return false;
}

function ensurePath() {
  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (Array.isArray(path)) {
    return path;
  } else if (typeof path === 'string') {
    return path.split('.');
  }

  return [];
}

function throwError(message) {
  throw new Error('Cerebral - ' + message);
}

function isDeveloping() {
  return process.env.NODE_ENV !== 'production';
}

function delay(func, wait) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;
    var later = function later() {
      func.apply(context, args);
    };

    setTimeout(later, wait);
  };
}

function forceSerializable(value) {
  if (value && !isSerializable(value)) {
    var name = value.constructor.name;

    try {
      Object.defineProperty(value, 'toJSON', {
        value: function value() {
          return '[' + name + ']';
        }
      });
    } catch (e) {}
  }

  return value;
}

function getProviders(module) {
  return Object.assign(module.providers || {}, Object.keys(module.modules || {}).reduce(function (nestedProviders, moduleKey) {
    return Object.assign(nestedProviders, getProviders(module.modules[moduleKey]));
  }, {}));
}

function extractAllChildMatches(children) {
  return Object.keys(children).reduce(function (matches, key) {
    if (children[key].children) {
      return matches.concat(children[key]).concat(extractAllChildMatches(children[key].children));
    }

    return matches.concat(children[key]);
  }, []);
}

function dependencyMatch(changes, dependencyMap) {
  var currentMatches = [];

  for (var changeIndex = 0; changeIndex < changes.length; changeIndex++) {
    var currentDependencyMapLevel = dependencyMap;
    for (var pathKeyIndex = 0; pathKeyIndex < changes[changeIndex].path.length; pathKeyIndex++) {
      if (!currentDependencyMapLevel) {
        break;
      }

      if (currentDependencyMapLevel['**']) {
        currentMatches.push(currentDependencyMapLevel['**']);
      }

      if (pathKeyIndex === changes[changeIndex].path.length - 1) {
        var dependency = currentDependencyMapLevel[changes[changeIndex].path[pathKeyIndex]];
        if (dependency) {
          currentMatches.push(dependency);

          if (dependency.children) {
            if (changes[changeIndex].forceChildPathUpdates) {
              currentMatches = currentMatches.concat(extractAllChildMatches(dependency.children));
            } else {
              if (dependency.children['**']) {
                currentMatches.push(dependency.children['**']);
              }

              if (dependency.children['*']) {
                currentMatches.push(dependency.children['*']);
              }
            }
          }
        }

        if (currentDependencyMapLevel['*']) {
          currentMatches.push(currentDependencyMapLevel['*']);
        }
      }

      if (!currentDependencyMapLevel[changes[changeIndex].path[pathKeyIndex]]) {
        currentDependencyMapLevel = null;
        break;
      }

      currentDependencyMapLevel = currentDependencyMapLevel[changes[changeIndex].path[pathKeyIndex]].children;
    }
  }

  return currentMatches;
}

function getWithPath(obj) {
  return function (path) {
    return path.split('.').reduce(function (currentValue, key, index) {
      if (index > 0 && currentValue === undefined) {
        throwError('You are extracting with path "' + path + '", but it is not valid for this object');
      }

      return currentValue[key];
    }, obj);
  };
}

function ensureStrictPath(path, value) {
  if (isComplexObject(value) && path.indexOf('*') === -1) {
    return path + '.**';
  }

  return path;
}

function createResolver(getters) {
  return {
    isTag: function isTag(arg) {
      if (!(arg instanceof _tags.Tag)) {
        return false;
      }

      for (var _len2 = arguments.length, types = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        types[_key2 - 1] = arguments[_key2];
      }

      if (types.length) {
        return types.reduce(function (isType, type) {
          return isType || type === arg.type;
        }, false);
      }

      return true;
    },
    isCompute: function isCompute(arg) {
      return arg instanceof _Compute.Compute;
    },
    value: function value(arg, overrideProps) {
      if (arg instanceof _tags.Tag || arg instanceof _Compute.Compute) {
        return arg.getValue(overrideProps ? Object.assign({}, getters, { props: overrideProps }) : getters);
      }

      return arg;
    },
    path: function path(arg) {
      if (arg instanceof _tags.Tag) {
        return arg.getPath(getters);
      }

      throwError('You are extracting a path from an argument that is not a Tag');
    }
  };
}

var noop = exports.noop = function noop() {};

/*
  When testing and running on the server there is no need to
  initialize all of Cerebral. So by not passing a controller
  to this Container it will create a dummy version which inserts
  state and mocks any signals when connecting the component.
*/
function createDummyController() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var signals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var getState = function getState(path) {
    return ensurePath(path).reduce(function (currentState, pathKey) {
      return currentState ? currentState[pathKey] : undefined;
    }, state);
  };
  return {
    options: {},
    on: function on() {},

    getState: getState,
    model: {
      get: getState
    },
    getSignal: function getSignal(signal) {
      return signals[signal] || function () {};
    },

    componentDependencyStore: {
      addEntity: noop,
      removeEntity: noop
    }
  };
}

function addCerebralStateKey(object) {
  if (isComplexObject(object)) {
    for (var key in object) {
      addCerebralStateKey(object[key]);
    }

    !object.__CerebralState && Object.defineProperty(object, '__CerebralState', {
      value: true
    });
  }

  return object;
}

function getStateTreeProp() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return Object.keys(props).reduce(function (hit, key) {
    if (!hit && isComplexObject(props[key]) && '__CerebralState' in props[key]) {
      return key;
    }

    return hit;
  }, null);
}

function getModule(path, modules) {
  var pathArray = Array.isArray(path) ? path : ensurePath(path);
  return pathArray.reduce(function (currentModule, key) {
    if (!currentModule.modules[key]) {
      throwError('The path "' + pathArray.join('.') + '" is invalid, can not find module. Does the path "' + pathArray.splice(0, path.length - 1).join('.') + '" exist?');
    }
    return currentModule.modules[key];
  }, modules);
}

function extractModuleProp(module, prop, transform) {
  var extracted = Object.keys(module.modules || {}).reduce(function (additionalExtracted, subModuleKey) {
    additionalExtracted[subModuleKey] = extractModuleProp(module.modules[subModuleKey], prop, transform);

    return additionalExtracted;
  }, {});

  if (module[prop]) {
    var extracedWithGetters = Object.keys(module[prop]).reduce(function (currentExtracted, key) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(module[prop], key);
      if (propertyDescriptor && 'get' in propertyDescriptor) {
        Object.defineProperty(currentExtracted, key, propertyDescriptor);
      } else {
        currentExtracted[key] = module[prop][key];
      }

      return currentExtracted;
    }, extracted);

    return transform ? transform(extracedWithGetters, module) : extracedWithGetters;
  }

  return extracted;
}
//# sourceMappingURL=utils.js.map