'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runSignal = exports.Snapshot = undefined;

var _snapshot = require('./snapshot');

Object.defineProperty(exports, 'Snapshot', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_snapshot).default;
  }
});
exports.runCompute = runCompute;
exports.CerebralTest = CerebralTest;
exports.runAction = runAction;

var _functionTree = require('function-tree');

var _ = require('..');

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function runCompute(compute) {
  var fixtures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var response = void 0;
  var rootModule = (0, _.Module)({
    state: fixtures.state || {},
    signals: {
      test: [function (_ref) {
        var resolve = _ref.resolve;

        response = resolve.value(compute, fixtures.props);
      }]
    }
  });
  var controller = (0, _.Controller)(rootModule);
  controller.getSignal('test')(fixtures.props);

  return response;
}

function _runSignal(signal) {
  var fixtures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return new Promise(function (resolve, reject) {
    var recordActions = options.recordActions && options.recordActions === 'byName' ? 'name' : 'functionIndex';
    var isSignal = Array.isArray(signal) || signal instanceof _functionTree.Primitive;
    var controller = options.controller || (0, _.Controller)((0, _.Module)(Object.assign({}, fixtures, isSignal && { signals: { signal: signal } })));
    var response = { controller: controller };

    var actionStart = function actionStart(execution, funcDetails, payload) {
      if (options.singleAction) {
        response.props = payload;
      } else {
        if (!options.noDuplicateWarnings && response[funcDetails[recordActions]]) {
          console.warn('Cerebral[runSignal]: signal contains actions with duplicate names (\'' + funcDetails[recordActions] + '\')');
        }
        response[funcDetails[recordActions]] = { props: payload };
      }
    };

    var actionEnd = function actionEnd(execution, funcDetails, payload, result) {
      if (!result || result instanceof _functionTree.Path && !result.payload) {
        return;
      }
      if (options.singleAction || response[funcDetails[recordActions]]) {
        var output = result instanceof _functionTree.Path ? result.payload : result;
        if (options.singleAction) {
          response.output = output;
        } else {
          response[funcDetails[recordActions]].output = output;
        }
      }
    };

    var error = function error(err) {
      off();
      reject(err);
    };

    var signalEnd = function signalEnd() {
      off();
      response.state = controller.getState();
      resolve(response);
    };

    var off = function off() {
      controller.off('functionStart', actionStart);
      controller.off('functionEnd', actionEnd);
      controller.off('error', error);
      controller.off('end', signalEnd);
    };

    controller.on('functionStart', actionStart);
    controller.on('functionEnd', actionEnd);
    controller.on('error', error);
    controller.on('end', signalEnd);
    controller.getSignal(isSignal ? 'signal' : signal)(fixtures.props);
  });
}

exports.runSignal = _runSignal;
function CerebralTest(rootModule) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { throwToConsole: false };

  var controller = (0, _.Controller)(rootModule, options);
  var model = controller.getModel();
  return {
    controller: controller,
    runSignal: function runSignal(signal, props) {
      return _runSignal(signal, { props: props }, Object.assign({}, options, { controller: controller, noDuplicateWarnings: true }));
    },
    setState: function setState(path, value) {
      model.set((0, _utils.ensurePath)((0, _utils.cleanPath)(path)), value);
      model.flush();
    },
    getState: function getState(path) {
      return model.get((0, _utils.ensurePath)((0, _utils.cleanPath)(path)));
    }
  };
}

function runAction(action) {
  var fixtures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return _runSignal([action], fixtures, {
    recordActions: true,
    singleAction: true
  });
}
//# sourceMappingURL=index.js.map