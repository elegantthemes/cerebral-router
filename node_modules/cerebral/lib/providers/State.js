'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.methods = undefined;
exports.default = StateProviderFactory;

var _utils = require('../utils');

var _Provider = require('../Provider');

var _Provider2 = _interopRequireDefault(_Provider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var methods = exports.methods = ['concat', 'get', 'increment', 'merge', 'pop', 'push', 'set', 'shift', 'splice', 'toggle', 'unset', 'unshift'];

function StateProviderFactory(devtools) {
  var asyncTimeout = null;

  return (0, _Provider2.default)(methods.reduce(function (currentState, methodKey) {
    currentState[methodKey] = function () {
      var _this = this;

      var model = this.context.controller.model;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var path = (0, _utils.ensurePath)((0, _utils.cleanPath)(args.shift()));

      if (methodKey === 'get') {
        return model.get(path);
      }

      if (this.context.controller.flush) {
        clearTimeout(asyncTimeout);
        asyncTimeout = setTimeout(function () {
          return _this.context.controller.flush();
        });
      }

      return model[methodKey].apply(model, [path].concat(args));
    };

    return currentState;
  }, {}), {
    wrap: devtools ? function (context, functionDetails) {
      var asyncTimeout = null;

      return methods.reduce(function (currentState, methodKey) {
        if (methodKey === 'get' || methodKey === 'compute') {
          currentState[methodKey] = function (path) {
            return context.controller.model[methodKey]((0, _utils.ensurePath)((0, _utils.cleanPath)(path)));
          };
        } else {
          var originFunc = context.controller.model[methodKey];

          currentState[methodKey] = function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var argsCopy = args.slice();
            var path = (0, _utils.ensurePath)(argsCopy.shift());

            context.debugger.send({
              datetime: Date.now(),
              type: 'mutation',
              color: '#333',
              method: methodKey,
              args: [path].concat(_toConsumableArray(argsCopy))
            });

            if (context.controller.flush) {
              clearTimeout(asyncTimeout);
              asyncTimeout = setTimeout(function () {
                return context.controller.flush();
              });
            }

            try {
              originFunc.apply(context.controller.model, [path].concat(_toConsumableArray(argsCopy)));
            } catch (e) {
              var signalName = context.execution.name;
              (0, _utils.throwError)('The Signal "' + signalName + '" with action "' + functionDetails.name + '" has an error: ' + e.message);
            }
          };
        }

        return currentState;
      }, {});
    } : false
  });
}
//# sourceMappingURL=State.js.map