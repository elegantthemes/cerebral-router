{"version":3,"sources":["../../src/providers/Recorder.js"],"names":["RecorderProvider","options","timeout","setTimeout","originalRunSignal","allowedSignals","currentRecording","currentSeek","currentEventIndex","lastEventTimestamp","nextEventTimeout","started","ended","isPlaying","isRecording","onFlush","events","push","type","timestamp","Date","now","onMutation","method","path","args","JSON","stringify","addExternalEvent","data","updateDebugger","context","debugger","window","CustomEvent","event","detail","dispatchEvent","mutate","mutation","parse","shift","controller","model","apply","concat","runNextEvent","flush","emit","runSignal","resetState","initialState","forEach","state","value","set","x","seek","clearTimeout","length","start","play","Error","indexOf","record","paths","map","arrayPath","split","getState","on","stop","wasPlaying","off","end","pause","getRecording","getCurrentSeek","loadRecording","recording"],"mappings":"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","file":"Recorder.js","sourcesContent":["import { Provider } from '../'\n\nexport default function RecorderProvider(options = {}) {\n  const timeout = options.setTimeout || setTimeout\n\n  // We will override the origin runSignal method to block\n  // signals from running while playing back recording\n  let originalRunSignal = null\n  let allowedSignals = []\n  let currentRecording = null\n  let currentSeek = 0\n  let currentEventIndex = 0\n  let lastEventTimestamp = 0\n  let nextEventTimeout = null\n  let started = null\n  let ended = null\n  let isPlaying = false\n  let isRecording = false\n\n  function onFlush() {\n    if (isRecording) {\n      currentRecording.events.push({\n        type: 'flush',\n        timestamp: Date.now(),\n      })\n    }\n  }\n\n  function onMutation({ method, path, args }) {\n    currentRecording.events.push({\n      type: 'mutation',\n      method,\n      args: JSON.stringify([path, ...args]),\n      timestamp: Date.now(),\n    })\n  }\n\n  function addExternalEvent(type, data) {\n    currentRecording.events.push({\n      type,\n      timestamp: Date.now(),\n      data,\n    })\n  }\n\n  function updateDebugger(method, path, args, context) {\n    if (\n      context.debugger &&\n      typeof window !== 'undefined' &&\n      window.CustomEvent\n    ) {\n      const event = new window.CustomEvent('cerebral2.client.message', {\n        detail: JSON.stringify({\n          type: 'recorderMutation',\n          data: {\n            method,\n            path,\n            args,\n          },\n        }),\n      })\n      window.dispatchEvent(event)\n    }\n  }\n\n  function mutate(mutation, context) {\n    const args = JSON.parse(mutation.args)\n    const path = args.shift()\n\n    context.controller.model[mutation.method].apply(\n      context.controller.model,\n      [path].concat(args)\n    )\n    updateDebugger(mutation.method, path, args, context)\n  }\n\n  // During playback we run events as they were recorded, one after\n  // the other\n  function runNextEvent(context) {\n    const event = currentRecording.events[currentEventIndex]\n\n    nextEventTimeout = timeout(() => {\n      if (event.type === 'mutation') {\n        mutate(event, context)\n      } else if (event.type === 'flush') {\n        context.controller.flush()\n      } else {\n        context.controller.emit(event.type, event.data)\n      }\n\n      lastEventTimestamp = event.timestamp\n      currentEventIndex++\n\n      if (!currentRecording.events[currentEventIndex]) {\n        context.controller.runSignal = originalRunSignal\n        isPlaying = false\n        currentEventIndex = 0\n\n        return\n      }\n\n      runNextEvent(context)\n    }, event.timestamp - lastEventTimestamp)\n  }\n\n  function resetState(context) {\n    currentRecording.initialState.forEach((state) => {\n      const value = JSON.parse(state.value)\n\n      context.controller.model.set(state.path, value)\n      updateDebugger('set', state.path, [value], context)\n    })\n    for (let x = 0; x < currentEventIndex; x++) {\n      if (currentRecording.events[x].type === 'mutation') {\n        mutate(currentRecording.events[x], context)\n      }\n    }\n  }\n\n  return Provider({\n    seek(seek) {\n      clearTimeout(nextEventTimeout)\n\n      for (let x = 0; x < currentRecording.events.length; x++) {\n        currentEventIndex = x\n\n        const event = currentRecording.events[x]\n        if (event.timestamp - currentRecording.start > seek) {\n          break\n        }\n      }\n\n      resetState(this.context)\n      this.context.controller.emit('recorder:seek', seek)\n    },\n    play(options = {}) {\n      if (isPlaying || isRecording) {\n        throw new Error(\n          'CEREBRAL Recorder - You can not play while already playing or recording'\n        )\n      }\n\n      allowedSignals = options.allowedSignals || []\n      resetState(this.context)\n      isPlaying = true\n      started = Date.now()\n      lastEventTimestamp = currentRecording.start\n\n      originalRunSignal = this.context.controller.runSignal\n      this.context.controller.runSignal = (...args) => {\n        if (allowedSignals.indexOf(args[0]) >= 0) {\n          originalRunSignal.apply(this.context.controller, args)\n        }\n      }\n      this.context.controller.flush(true)\n      runNextEvent(this.context)\n      this.context.controller.emit('recorder:play', currentSeek, options)\n    },\n    record(options = {}) {\n      // If we are recording over the previous stuff, go back to start\n      if (currentRecording) {\n        currentSeek = 0\n        ended = null\n      }\n\n      const paths = options.initialState || ['']\n      const state = paths.map((path) => {\n        const arrayPath = path ? path.split('.') : []\n\n        return {\n          path: arrayPath,\n          value: JSON.stringify(this.context.controller.getState(arrayPath)),\n        }\n      })\n\n      currentRecording = {\n        initialState: state,\n        start: Date.now(),\n        events: [],\n      }\n\n      this.context.controller.on('recorder:event', addExternalEvent)\n\n      isRecording = true\n      this.context.controller.emit('recorder:record', options)\n\n      // We need to record flush events to update the UI\n      // at the same time as during the recording\n      this.context.controller.on('flush', onFlush)\n      this.context.controller.on('mutation', onMutation)\n\n      originalRunSignal = this.context.controller.runSignal\n    },\n    stop() {\n      const wasPlaying = isPlaying\n      clearTimeout(nextEventTimeout)\n      isPlaying = false\n      isRecording = false\n      this.context.controller.runSignal = originalRunSignal\n      this.context.controller.off('recorder:event', addExternalEvent)\n\n      if (wasPlaying) {\n        return\n      }\n\n      currentRecording.end = Date.now()\n      currentEventIndex = 0\n      currentRecording.events.push({\n        type: 'flush',\n        timestamp: Date.now(),\n      })\n      this.context.controller.emit('recorder:stop')\n      this.context.controller.off('flush', onFlush)\n      this.context.controller.off('mutation', onMutation)\n    },\n    pause() {\n      ended = Date.now()\n      currentSeek = ended - started\n      clearTimeout(nextEventTimeout)\n      isPlaying = false\n      this.context.controller.emit('recorder:pause', currentSeek)\n    },\n    getRecording() {\n      return currentRecording\n    },\n    getCurrentSeek() {\n      return currentSeek\n    },\n    loadRecording(recording) {\n      currentRecording = recording\n    },\n    isRecording() {\n      return isRecording\n    },\n  })\n}\n"]}