{"version":3,"sources":["../../src/providers/State.js"],"names":["StateProviderFactory","methods","devtools","asyncTimeout","reduce","currentState","methodKey","model","context","controller","args","path","shift","get","flush","clearTimeout","setTimeout","apply","concat","wrap","functionDetails","originFunc","argsCopy","slice","debugger","send","datetime","Date","now","type","color","method","e","signalName","execution","name","message"],"mappings":"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","file":"State.js","sourcesContent":["import { ensurePath, cleanPath, throwError } from '../utils'\nimport Provider from '../Provider'\n\nexport const methods = [\n  'concat',\n  'get',\n  'increment',\n  'merge',\n  'pop',\n  'push',\n  'set',\n  'shift',\n  'splice',\n  'toggle',\n  'unset',\n  'unshift',\n]\n\nexport default function StateProviderFactory(devtools) {\n  let asyncTimeout = null\n\n  return Provider(\n    methods.reduce((currentState, methodKey) => {\n      currentState[methodKey] = function(...args) {\n        const model = this.context.controller.model\n        const path = ensurePath(cleanPath(args.shift()))\n\n        if (methodKey === 'get') {\n          return model.get(path)\n        }\n\n        if (this.context.controller.flush) {\n          clearTimeout(asyncTimeout)\n          asyncTimeout = setTimeout(() => this.context.controller.flush())\n        }\n\n        return model[methodKey].apply(model, [path].concat(args))\n      }\n\n      return currentState\n    }, {}),\n    {\n      wrap: devtools\n        ? (context, functionDetails) => {\n            let asyncTimeout = null\n\n            return methods.reduce((currentState, methodKey) => {\n              if (methodKey === 'get' || methodKey === 'compute') {\n                currentState[methodKey] = (path) => {\n                  return context.controller.model[methodKey](\n                    ensurePath(cleanPath(path))\n                  )\n                }\n              } else {\n                const originFunc = context.controller.model[methodKey]\n\n                currentState[methodKey] = (...args) => {\n                  const argsCopy = args.slice()\n                  const path = ensurePath(argsCopy.shift())\n\n                  context.debugger.send({\n                    datetime: Date.now(),\n                    type: 'mutation',\n                    color: '#333',\n                    method: methodKey,\n                    args: [path, ...argsCopy],\n                  })\n\n                  if (context.controller.flush) {\n                    clearTimeout(asyncTimeout)\n                    asyncTimeout = setTimeout(() => context.controller.flush())\n                  }\n\n                  try {\n                    originFunc.apply(context.controller.model, [\n                      path,\n                      ...argsCopy,\n                    ])\n                  } catch (e) {\n                    const signalName = context.execution.name\n                    throwError(\n                      `The Signal \"${signalName}\" with action \"${\n                        functionDetails.name\n                      }\" has an error: ${e.message}`\n                    )\n                  }\n                }\n              }\n\n              return currentState\n            }, {})\n          }\n        : false,\n    }\n  )\n}\n"]}