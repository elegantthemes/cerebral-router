'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DependencyStore = function () {
  function DependencyStore() {
    _classCallCheck(this, DependencyStore);

    this.map = {};
  }
  /*
    Adds the entity to all the depending paths
  */


  _createClass(DependencyStore, [{
    key: 'addEntity',
    value: function addEntity(entity, depsMap) {
      var _this = this;

      var _loop = function _loop(depsMapKey) {
        var path = depsMapKey.split('.');

        path.reduce(function (currentMapLevel, key, index) {
          if (!currentMapLevel[key]) {
            currentMapLevel[key] = {};
          }

          if (index < path.length - 1) {
            currentMapLevel[key].children = currentMapLevel[key].children || {};

            return currentMapLevel[key].children;
          }

          currentMapLevel[key].entities = currentMapLevel[key].entities ? currentMapLevel[key].entities.concat(entity) : [entity];

          return currentMapLevel;
        }, _this.map);
      };

      for (var depsMapKey in depsMap) {
        _loop(depsMapKey);
      }
    }
    /*
      Removes the entity from all depending paths
    */

  }, {
    key: 'removeEntity',
    value: function removeEntity(entity, depsMap) {
      var _this2 = this;

      var _loop2 = function _loop2(depsMapKey) {
        var path = depsMapKey.split('.');
        path.reduce(function (currentMapLevel, key, index) {
          if (index === path.length - 1) {
            currentMapLevel[key].entities.splice(currentMapLevel[key].entities.indexOf(entity), 1);

            if (!currentMapLevel[key].entities.length) {
              delete currentMapLevel[key].entities;
            }
          }

          return currentMapLevel[key].children;
        }, _this2.map);
      };

      for (var depsMapKey in depsMap) {
        _loop2(depsMapKey);
      }
    }
    /*
      Updates entity based on changed dependencies
    */

  }, {
    key: 'updateEntity',
    value: function updateEntity(entity, prevDepsMap, nextDepsMap) {
      var toRemove = Object.keys(prevDepsMap).reduce(function (removeDepsMap, prevDepsMapKey) {
        if (!nextDepsMap[prevDepsMapKey]) {
          removeDepsMap[prevDepsMapKey] = true;
        }

        return removeDepsMap;
      }, {});
      var toAdd = Object.keys(nextDepsMap).reduce(function (addDepsMap, nextDepsMapKey) {
        if (!prevDepsMap[nextDepsMapKey]) {
          addDepsMap[nextDepsMapKey] = true;
        }

        return addDepsMap;
      }, {});

      this.removeEntity(entity, toRemove);

      this.addEntity(entity, toAdd);
    }
    /*
      As same entity can appear in multiple paths, this method returns
      all unique entities. Used by view to render all components
    */

  }, {
    key: 'getAllUniqueEntities',
    value: function getAllUniqueEntities() {
      var entities = [];

      function traverseChildren(children) {
        for (var childKey in children) {
          if (children[childKey].entities) {
            for (var y = 0; y < children[childKey].entities.length; y++) {
              if (entities.indexOf(children[childKey].entities[y]) === -1) {
                entities.push(children[childKey].entities[y]);
              }
            }
          }

          if (children[childKey].children) {
            traverseChildren(children[childKey].children);
          }
        }
      }
      traverseChildren(this.map);

      return entities;
    }
    /*
      Returns entities based on a change map returned from
      the model flush method.
    */

  }, {
    key: 'getUniqueEntities',
    value: function getUniqueEntities(changesMap) {
      return (0, _utils.dependencyMatch)(changesMap, this.map).reduce(function (unique, match) {
        return (match.entities || []).reduce(function (currentUnique, entity) {
          if (currentUnique.indexOf(entity) === -1) {
            return currentUnique.concat(entity);
          }

          return currentUnique;
        }, unique);
      }, []);
    }
  }]);

  return DependencyStore;
}();

exports.default = DependencyStore;
//# sourceMappingURL=DependencyStore.js.map