{"version":3,"sources":["../../src/operators/set.js"],"names":["target","value","set","state","module","props","resolve","isTag","Error","resolvedValue","isResolveValue","Object","assign","Array","isArray","slice","type","path","result","parts","split","key","pop","targetObj","reduce","displayName","String"],"mappings":";;;;;;kBAEe,UAASA,MAAT,EAAiBC,KAAjB,EAAwB;AACrC,WAASC,GAAT,OAAgD;AAAA,QAAjCC,KAAiC,QAAjCA,KAAiC;AAAA,QAA1BC,MAA0B,QAA1BA,MAA0B;AAAA,QAAlBC,KAAkB,QAAlBA,KAAkB;AAAA,QAAXC,OAAW,QAAXA,OAAW;;AAC9C,QAAI,CAACA,QAAQC,KAAR,CAAcP,MAAd,EAAsB,OAAtB,EAA+B,OAA/B,EAAwC,QAAxC,CAAL,EAAwD;AACtD,YAAM,IAAIQ,KAAJ,CACJ,yFADI,CAAN;AAGD;;AAED,QAAIC,gBAAgBH,QAAQL,KAAR,CAAcA,KAAd,CAApB;;AAEA,QAAI,CAACK,QAAQI,cAAR,CAAuBT,KAAvB,CAAD,IAAkC,qBAASA,KAAT,CAAtC,EAAuD;AACrDQ,sBAAgBE,OAAOC,MAAP,CAAc,EAAd,EAAkBH,aAAlB,CAAhB;AACD,KAFD,MAEO,IAAI,CAACH,QAAQI,cAAR,CAAuBT,KAAvB,CAAD,IAAkCY,MAAMC,OAAN,CAAcb,KAAd,CAAtC,EAA4D;AACjEQ,sBAAgBA,cAAcM,KAAd,EAAhB;AACD;;AAED,QAAIf,OAAOgB,IAAP,KAAgB,OAApB,EAA6B;AAC3Bb,YAAMD,GAAN,CAAUI,QAAQW,IAAR,CAAajB,MAAb,CAAV,EAAgCS,aAAhC;AACD,KAFD,MAEO,IAAIT,OAAOgB,IAAP,KAAgB,QAApB,EAA8B;AACnCZ,aAAOF,GAAP,CAAWI,QAAQW,IAAR,CAAajB,MAAb,CAAX,EAAiCS,aAAjC;AACD,KAFM,MAEA;AACL,UAAMS,SAASP,OAAOC,MAAP,CAAc,EAAd,EAAkBP,KAAlB,CAAf;AACA,UAAMc,QAAQb,QAAQW,IAAR,CAAajB,MAAb,EAAqBoB,KAArB,CAA2B,GAA3B,CAAd;AACA,UAAMC,MAAMF,MAAMG,GAAN,EAAZ;AACA,UAAMC,YAAYJ,MAAMK,MAAN,CAAa,UAACxB,MAAD,EAASqB,GAAT,EAAiB;AAC9C,eAAQrB,OAAOqB,GAAP,IAAcV,OAAOC,MAAP,CAAc,EAAd,EAAkBZ,OAAOqB,GAAP,KAAe,EAAjC,CAAtB;AACD,OAFiB,EAEfH,MAFe,CAAlB;AAGAK,gBAAUF,GAAV,IAAiBZ,aAAjB;;AAEA,aAAOS,MAAP;AACD;AACF;;AAEDhB,MAAIuB,WAAJ,qBAAkCC,OAAO1B,MAAP,CAAlC,UAAqD0B,OAAOzB,KAAP,CAArD;;AAEA,SAAOC,GAAP;AACD,C;;AAtCD","file":"set.js","sourcesContent":["import { isObject } from '../utils'\n\nexport default function(target, value) {\n  function set({ state, module, props, resolve }) {\n    if (!resolve.isTag(target, 'state', 'props', 'module')) {\n      throw new Error(\n        'Cerebral operator.set: You have to use the STATE, PROPS or MODULE tag as first argument'\n      )\n    }\n\n    let resolvedValue = resolve.value(value)\n\n    if (!resolve.isResolveValue(value) && isObject(value)) {\n      resolvedValue = Object.assign({}, resolvedValue)\n    } else if (!resolve.isResolveValue(value) && Array.isArray(value)) {\n      resolvedValue = resolvedValue.slice()\n    }\n\n    if (target.type === 'state') {\n      state.set(resolve.path(target), resolvedValue)\n    } else if (target.type === 'module') {\n      module.set(resolve.path(target), resolvedValue)\n    } else {\n      const result = Object.assign({}, props)\n      const parts = resolve.path(target).split('.')\n      const key = parts.pop()\n      const targetObj = parts.reduce((target, key) => {\n        return (target[key] = Object.assign({}, target[key] || {}))\n      }, result)\n      targetObj[key] = resolvedValue\n\n      return result\n    }\n  }\n\n  set.displayName = `operator.set(${String(target)}, ${String(value)})`\n\n  return set\n}\n"]}